\documentclass[20pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{url}
\usepackage[colorlinks,allcolors=blue]{hyperref}
\usepackage[numbers]{natbib}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage[outdir=./]{epstopdf}
\usepackage{listings}
\usepackage{hyperref}

\newtheorem*{mydef}{Определение}

\title{Дипломная работа}
\author{Козлов Никита}

\begin{document}

\thispagestyle{empty}

\begin{center}
\ \vspace{-4cm}

\includegraphics[width=0.5\textwidth]{msu}\\
{Московский государственный университет имени М.В.~Ломоносова}\\
Факультет вычислительной математики и кибернетики\\
Кафедра автоматизации систем вычислительных комплексов (АСВК)

\vspace{5cm}

{\Large Козлов~Никита~Вячеславович}

\vspace{1cm}

{\Large\bfseries
Извлечение данных о состоянии веб-приложения на основе анализа образа памяти веб-сервера\\ }

\vspace{1cm}

{\large ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА}
\end{center}

\vfill

\begin{flushright}
  \textbf{Научный руководитель:}\\
  м.н.с. А.А.~Петухов
\end{flushright}

\vfill

\begin{center}
Москва, 2017
\end{center}

\enlargethispage{4\baselineskip}

\newpage

\section*{Аннотация}
Данная работа посвящена исследованию возможности извлечения конфиденциальных
данных из образа памяти веб-сервера работающего под управление операционной
системы из семества unix-подобных. Для исследований и экспериментов использовался
веб-сервер Apache, а в качестве системы управления содержимым сайта использовался
Wordpress. На полученной системе были протестированы различные методы извлечения
приватного ключа и других конфиденциальных данных.

\newpage

\tableofcontents

\newpage

\section{Введение}

\subsection{Предметная область}

Веб-приложения играют значительную роль в жизни современного общества. С их
помощью люди могут оформлять документы, заказывать любые товары, покупать и
продавать ценные бумаги и многое другое. Для работы любого такого веб-приложения
необходим веб-сервер, который будет обслуживать всех клиентов.

Веб-сервер \cite{wiki/web-server} — сервер, принимающий HTTP-запросы от клиентов,
обычно веб-браузеров, и выдающий им HTTP-ответы, как правило, вместе с
HTML-страницей, изображением, файлом, медиа-потоком или другими данными.

Веб-сервером называют как программное обеспечение, выполняющее функции веб-сервера,
так и непосредственно станцию, на которой это программное обеспечение работает.

Клиент, которым обычно является веб-браузер, передаёт веб-серверу запросы на
получение ресурсов, адресуемых идентификаторами в формате URL. Ресурсы — это
HTML-страницы, изображения, файлы, медиа-потоки или другие данные, которые
необходимы клиенту. В ответ веб-сервер передаёт клиенту запрошенные данные.
Этот обмен происходит по протоколу HTTP.

\subsection{Дамп памяти}

Дамп памяти \cite{wiki/coredump} - это содержимое рабочей памяти процесса, его
формирует операционная система в случае, когда процесс завершается из-за
критической ошибки \cite{core-dump-signals} \cite{error-types}. Сигналы, которые
посылает операционная система из семейства UNIX, приводящие к экстренному завершению
работы процесса и созданию дампа памяти:
\begin{itemize}
  \item SIGFPE - критичная ошибка в арифметической операции.
  \begin{itemize}
    \item Деление на ноль.
  \end{itemize}
  \item SIGILL - недопустимая инструкция.
  \item SIGSEGV - ошибка доступа к памяти.
    \begin{itemize}
      \item Переполнение буфера \cite{buffer-overflow}.
      \item Переполнение стека \cite{stack-overflow}.
      \item Переполнение кучи \cite{heap-overflow}.
      \item Обращение на чтение или запись к области памяти для которой запрещены
      чтение или запись \cite{memory-corruption}.
    \end{itemize}
  \item SIGBUS - разыменовывание недопустимого указателя.
  \item SIGABRT - вызов функции abort.
    \begin{itemize}
      \item Освобождение ранее не выделенной памяти.
    \end{itemize}
  \item SIGTRAP - достигнута точка останова.
  \item SIGEMT - ошибка эмулятора.
  \item SIGSYS - невалидный системный вызов.
  \item SIGQUIT - критичная ситуация замеченная программой \cite{sigquit}.
\end{itemize}

Максимальный размер дампа памяти зависит от настроек операционной системы -
значения RLIMIT\_CORE. Размеры дампов памяти, полученных в тестовых условиях,
находятся в пределах нескольких сотен мегабайт, размер дампа памяти, полученного
на реальном сервере составляет 30Мб.

Дамп памяти может включать в себя значения регистров процессора, содержимое стека,
глобальные переменные, переменные окружения, локальные переменные и аргументы
функций во всех фреймах на момент создания дампа памяти и т.д. С его помощью
разработчик может посмотреть состояние программы на момент ошибки. Пример анализа
дампа памяти на следующем листинге \ref{gdb-core-dump}.

\begin{lstlisting}[caption={Анализ дампа памяти в gdb},label={gdb-core-dump},breaklines]
> gdb -q /usr/sbin/apache2 core.apache2.23383
Reading symbols from /usr/sbin/apache2...Reading symbols from /usr/lib/debug//usr/sbin/apache2...done.
done.
[New LWP 23383]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Core was generated by `/usr/sbin/apache2 -k start'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007fbbfa5b957f in do_fcntl (arg=0x7fbbfa9f88e0, cmd=7, fd=14)
    at ../sysdeps/unix/sysv/linux/fcntl.c:39
(gdb) bt
#0  0x00007fbbfa5b957f in do_fcntl (arg=0x7fbbfa9f88e0, cmd=7, fd=14)
    at ../sysdeps/unix/sysv/linux/fcntl.c:39
#1  __libc_fcntl (fd=14, cmd=7) at ../sysdeps/unix/sysv/linux/fcntl.c:88
#2  0x00007fbbfa7e1296 in ?? () from /usr/lib/x86_64-linux-gnu/libapr-1.so.0
#3  0x00007fbbf79165a2 in accept_mutex_on () at prefork.c:232
#4  child_main (child_num_arg=child_num_arg@entry=4) at prefork.c:611
#5  0x00007fbbf79169a6 in make_child (s=0x7fbbfb310de0, slot=slot@entry=4) at prefork.c:800
#6  0x00007fbbf7916a06 in startup_children (number_to_start=1) at prefork.c:818
#7  0x00007fbbf79176e0 in prefork_run (_pconf=<optimized out>, plog=0x7fbbfb30c028,
    s=0x7fbbfb310de0) at prefork.c:976
#8  0x00007fbbfb0f19ce in ap_run_mpm (pconf=0x7fbbfb33f028, plog=0x7fbbfb30c028,
    s=0x7fbbfb310de0) at mpm_common.c:94
#9  0x00007fbbfb0eb1a6 in main (argc=3, argv=0x7fffb086f128) at main.c:777
(gdb) select-frame 8
(gdb) info args
pconf = 0x7fbbfb33f028
plog = 0x7fbbfb30c028
s = 0x7fbbfb310de0
(gdb) info locals
pHook = 0x7fbbfb27f660
n = 0
rv = -4
(gdb) select-frame 9
(gdb) info args
argc = 3
argv = 0x7fffb086f128
(gdb) quit
\end{lstlisting}

Для создания дампа памяти должны быть соблюдены следующие требования \cite{man/coredump}:
\begin{itemize}
  \item Процесс должен иметь права на запись файла. По умолчанию дамп памяти
  называется core и создается в рабочей директории приложения.
  \item Если существует файл, с таким же именем с каким будет создан дамп памяти,
  то этот файл должен иметь не более одной жесткой ссылки (hard link).
  \item Директория в которой будет создан дамп памяти должна существовать.
  \item RLIMIT\_CORE и RLIMIT\_SIZE (максимальный размер файла) не должны быть равны 0.
\end{itemize}

\subsection{Конфиденциальные данные}

В памяти веб-сервера могут находиться следующие конфиденциальные данные, которые
могут заинтересовать злоумышленника:

\begin{itemize}

  \item Cookies, логины, пароли или хеши паролей пользователей. С их
  помощью можно получить неограниченный доступ к аккаунту пользователя.

  \item Конфигурационные файлы веб-сервера, исходные коды веб-сервиса и даже переменные
  окружения содержат информацию, которая может помочь атакующему найти и
  эксплуатировать различные уязвимости.

  \item Конфигурационные файлы веб-сервиса, которые могут содержать логины,
  пароли, токены для доступа к базам данных, FTP серверам и другим сервисам,
  попадание которых в руки злоумышленника может привести к раскрытию данных
  пользователей сервиса и компроментации самого сервиса.

  \item Для шифрования общения между клиентом и сервером используется криптографический
  протокол TLS \cite{tls} или его предшественник SSL. Для аутентификации сервера
  используются инфраструктура открытых ключей \cite{pki}. Одним из ключевых моментов
  инфраструктуры открытых ключей является то, что приватный ключ должен быть
  известен только владельцу сервера. Если злоумышленник сможет похитить приватный
  ключ, то он сможет осуществить атаку "Человек посередине" \cite{mitm}.

\end{itemize}

\newpage

\section{Цель работы и постановка задачи}

Цель работы - исследовать возможность получения конфиденциальных данных из
дампа памяти веб-сервера.

\subsection{Постановка задачи}

На примере веб-сервера Apache и системы управления содержимым сайта Wordpress
исследовать возможность получения конфиденциальной информации из дампов памяти
веб-сервера. Для достижения поставленной цели необходимо:

\begin{enumerate}
  \item Ознакомиться с работами в предметной области.
  \item Настроить окружение для проведения исследований.
  \item Воспроизвести результаты интересующих работ изученных на первом шаге.
  \item Вручную проанализировать содержимое нескольких дампов памяти.
  \item Написать утилиту для извлечения конфиденциальных данных.
  \item Настроить автоматическое создание окружения.
  \item Провести автоматическое тестирование на наличие конфиденциальных данных
  в разных дистрибутивах.
\end{enumerate}

\newpage

\subsection{Актуальность}

Дамп памяти может содержать различные конфиденциальные данные, которые могут
привести к утечке пользовательских данных или компометации всего веб-сервиса.
Таким образом они представляют интерес для злоумышленников.

На январь 2016 года, 33.56\% сайтов работали на Apache \cite{number_of_apache_sites}.
Если в частности рассматривать популярную систему управления содержимым Wordpress,
то на 2 мая 2017 года 27.9\% сайтов работают под её правлением. \cite{number_of_wordpress_sites}.

В Apache было найдено как минимум 777 \cite{apache/vulnerabilities-list} уязвимостей,
а в интерпретаторе PHP 538 \cite{php/vulnerabilities-list}.

В экосистеме Wordpress (ядро, плагины, темы) было найдено как минимум 6892
уязвимостей \cite{wordpress/vulnerablilities-list-all}, из них 254
уязвимости \cite{wordpress/vulnerabilities-list-core} в ядре.

Некоторые из этих уязвимостей позволяют вызывать создание дампа памяти, а
некоторые дают возможность его прочитать. При этом существует неправильно
сконфигурированные веб-сервера, которые позволяют читать файлы из корневой
директории и соотвествующих поддиректорий.

\newpage

\section{Методы вызова создания дампа памяти}

Атакующий может создать дамп эксплуатируя ошибки, приводящие к экстренному
завершение работы веб-сервера. Вот примеры таких ошибок \cite{php/crash}:
\begin{itemize}
  \item  Бесконечная рекурсия.
    \begin{itemize}
      \item Ошибка в библиотеке GD, проверка условия выхода из рекурсии
      опредленным образом зависела от структуры данного изображения. Специально
      сконструированное изображение вызывало переполнение буфера и экстренное
      завершение работы интерпретатора PHP.
    \end{itemize}
  \item Ошибки в библиотеках.
    \begin{itemize}
      \item Ошибки обработки заголовков. Существуют расширения PHP,такие как exif, GD,
        imagemagic и другие, которые позволяют работать с изображениями. Для работы
        с изображениями необходимо выделить память, а необходимый объем определяется
        с помощью заголовков изображения. Таким образом выставляя специальные значения
        заголовков можно добиться экстренного завершнения работы интерпретатора PHP.
    \end{itemize}
  \item Ошибки в различных встроенных функциях.
    \begin{itemize}
      \item CVE-2010-3710 \cite{cve-2010-3710}. Если был включен режим
      FILTER\_VALIDATE\_EMAIL, то злоумышленник мог вызвать отказ работы сервиса,
      послав очень длинный почтовый адрес, его проверка вызывала использование
      большого объема памяти.
      \item Ошибка в функции pack(). Будучи вызванной со специальными аргументами
      эта функция заставляет интерпретатор PHP выделить памяти больше чем есть
      на сервере, что вызовет экстренное завершение работы интерпретатора PHP.
    \end{itemize}
 \item Ошибки в коде дополнительных модулей.
 \item Другие ошибки.
\end{itemize}

\newpage

\section{Способы получения дампа памяти}

Атакующий может получить дамп памяти разными способами:
\begin{itemize}
  \item При неправильной конфигурации веб-сервера становится возможным чтение
  файлов из поддиректорий корневой директории веб-сервиса \cite{directory-listing},
  куда может быть сохранен дамп памяти. Директория с дампами памяти задается
  диррективой CoreDumpDirectory в конфигурационных файлах веб-сервера Apache.
  По умолчанию дамп памяти называется core и создается в рабочей папке приложения.
  \item Открытый FTP сервер или FTP сервер с пользователем и паролем, которые
  легко перебрать.
  \item Directory traversal \cite{directory-traversal}.
  Если на сайте присутствует форма просмотра или скачивания некоторого файла,
  в которой не фильтруется название этого файла, задаваемого пользователем, то
  злоумышленник может задать название вида "../../../../../etc/passwd" и просмотреть
  или скачать содержимое этого файла.
  \item XML external entity \cite{xxe} + php-wrapper \cite{php-wrappers}
  Cайт может быть уязвим, если обрабатывает XML-документы, на содержание которых
  влияет пользователь, а пользовательские данные не фильтруются должным образом.
  Атакующий может добавить в документ внешнюю сущность '<!ENTITY xxe SYSTEM "file://etc/passwd" >]>',
  с помощью которой может скачать любой текстовый файл. Для того чтобы скачать
  произвольный файл, нужно использовать php-wrappers, с их помощью можно
  конвертировать исходный файл в несколько форматов, например base64:
  "php://filter/convert.base64-encode/resource=/etc/passwd".
  \item Другие атаки.
\end{itemize}

\section{Извлечение конфиденциальных данных}

\subsection{Исследования в предметной области}

Heartbleed \cite{heartbleed} - критическая уязвимость в популярной криптографической
библиотеке OpenSSL. Эта уязвимость позволяла атакующему, пославшему специально
сформированный пакет, читать части оперативной памяти размером до 64КБ. Таким
образом атакующий мог подслушивать части взаимодействия пользователей с сервисом.
Скомпрометированными могли оказаться приватные ключи, используемые для шифрования,
логины и пароли пользователей и другие конфиденциальные данные.

После того как была опубликована информация об уязвимости, компания CloudFlare
провела собственное расследование \cite{heartbleed/investigation}, целью которого
было выяснить, возможно ли извлечь приватный ключ из памяти веб-сервера с
уязвимой версией OpenSSL. Во время расследования у инженеров компании не
получилось извлечь приватный ключ. Для изучения проблемы было организовано
публичное соревнование \cite{heartbleed/investigation} с той же самой целью.
Каждый желающий мог попробовать извлечь приватный ключ из данного веб-сервера с
уязвимой версией OpenSSL.

Победителем данного соревнования стали Fedor Indutny \cite{heartbleed/Indutny} и
Ilkka Mattila через 9 часов с момента старта соревнования. Они успешно смогли
извлечь приватный ключ. Fedor смог получить ключ отправив около 2.5 миллионов
запросов, а у Ilkka получилось это сделать за 100 тысяч запросов.

По итогам соревнования coudflare рекомендовала всем перевыпустить все сертификаты
и ускорила перевыпуск сертификатов своих клиентов.


\subsection{Методы извлечения приватного ключа RSA \cite{playing-hide-and-seek-with-stored-keys} }

\subsubsection{Введение}

В основу криптографической системы с открытым ключом RSA положена сложность задачи
факторизации произведения двух больших простых чисел. Для шифрования используется
операция возведения в степень по модулю большого числа. Для дешифрования за
разумное время необходимо уметь вычислять функцию Эйлера от данного большого
числа, для чего необходимо знать разложение числа на простые множители.

Важные числа в криптографической системе RSA:
\begin{itemize}
  \item простые числа $p$ и $q$
  \item их произведение $n=p \cdot q$, которое называется модулем
  \item значение функции Эйлера от числа $n$: $\varphi (n)=(p-1)\cdot (q-1)$.
  \item целое число $e$, которое называется открытой экспонентой
    (1<$e$<$\varphi$ ($n$)), взаимно простое со значением функции $\varphi(n)$.
  \item число $d$, мультипликативно обратное к числу $e$ по модулю
    $\varphi$ ($n$), то есть число, удовлетворяющее сравнению: $d\cdot e\equiv 1{\pmod {\varphi (n)}}$.
\end{itemize}

Пара {$e$, $n$} публикуется в качестве открытого ключа RSA .
Пара {$d$, $n$} играет роль закрытого ключа RSA и держится в секрете.

\subsubsection{Исходные данные}

Известны n и e используемые в схеме RSA, их можно узнать из TLS/SSL сертификата
веб-сервиса. Строка длинны u - содержимое дампа памяти процесса веб-сервера, для
которой известно, что она содержит приватный ключ d как последовательную запись
длинны v бит. Обычно v имеет порядок $10^3$.

\subsubsection{Алгоритм: последовательный перебор}

Простейший способ поиска приватного ключа, который применим ко всем
криптосистемам, заключается в том, чтобы получить пару открытый текст/шифротекст,
а затем сканировать данную последовательность и проводить попытки дешифровки
шифротекста, используя как ключ каждую последовательность длинны v.

Пару открытый текст/шифротекст можем получить зашифровав некоторый открытый текст
публичным ключом.

Редкие ложноположительные результаты могут быть устранены проверкой
дополнительных пар текст/шифротекст.

\subsubsection{Алгоритм: поиск делителей}

Данный подход заключается в поиске в данной строке делители модуля n - p и q.
Несмотря на то, что серверу нет необходимости хранить делители в памяти, так
как нужно считать лишь $m^d$(mod n), почти все реализации RSA их хранят в
целях оптимизации вычислений.

Структура приватного ключа в библиотеке OpenSSL приведена в листинге \ref{rsa-data-structure}.

\begin{lstlisting}[caption={Структура приватного ключа RSA},label={rsa-data-structure},breaklines]
struct rsa_st
  {
  /* The first parameter is used to pickup errors where
   * this is passed instead of aEVP_PKEY, it is set to 0 */
  int pad;
  long version;
  const RSA_METHOD *meth;
  /* functional reference if 'meth' is ENGINE-provided */
  ENGINE *engine;
  BIGNUM *n;
  BIGNUM *e;
  BIGNUM *d;
  BIGNUM *p;
  BIGNUM *q;
  BIGNUM *dmp1;
  BIGNUM *dmq1;
  BIGNUM *iqmp;
  /* be careful using this if the RSA structure is shared */
  CRYPTO_EX_DATA ex_data;
  int references;
  int flags;

  /* Used to cache montgomery values */
  BN_MONT_CTX *_method_mod_n;
  BN_MONT_CTX *_method_mod_p;
  BN_MONT_CTX *_method_mod_q;

  /* all BIGNUM values are actually in the following data, if it is not
   * NULL */
  char *bignum_data;
  BN_BLINDING *blinding;
  BN_BLINDING *mt_blinding;
  };
\end{lstlisting}

Структура BIGNUM показана в листинге \ref{bignum-data-structure}:
\begin{lstlisting}[caption={Структура BIGNUM},label={bignum-data-structure},breaklines]
  struct bignum_st
  {
  BN_ULONG *d;    /* Pointer to an array of 'BN_BITS2' bit chunks. */
  int top;    /* Index of last used d +1. */
  /* The next are internal book keeping for bn_expand. */
  int dmax;    /* Size of the d array. */
  int neg;    /* one if the number is negative */
  int flags;
  };
\end{lstlisting}

Делители n хранятся в памяти, а поле d структуры BIGNUM указывает на
значение числа.

Используя реализацию этого алгорима, получилось извлечь
приватный ключ TLS\textbackslash SSL из дампа памяти на тестовом стенде.

\subsubsection{Алгоритм: анализ структур кода приложения}

Альтернативным способом нахождения приватного ключа является поиск структур
данных, специфичных для конкретного веб-сервера. Поиск опирается на нахождение
структуры данных в которой хранится приватный ключ [листинг \ref{rsa-data-structure}],
в дампе памяти находится эта структура данных, и производится попытка расшифровать
некоторое сообщение или найти делитель модуля.

Таким образом работает утилита passe-partout \cite{passe-partout}, которая может
извлекать приватный ключ из памяти работающего веб-приложения. В данный момент
использовать эту утилиту для извлечения приватного ключа RSA из дампа памяти
нельзя, так как утилита работает только с запущенными процессами.

\subsubsection{Оптимизации: поиск мест с высокой энтропией}

Процесс поиска можно оптимизировать, если понять какими отличительными
характеристиками обладает объект поиска, и искать места с этими характеристиками.
Большая часть кода и данных формируется неслучайным образом, а криптографические
ключи редко выбирается неслучайно. Таким образом можно утверждать, что
криптографические ключи находятся в области с высокой энтропией.

\subsection{Извлечение других конфиденциальных данных}

\subsubsection{Извлечение логинов и паролей, конфигурационных файлов}

Изучив тестовые дампы памяти, можно составить список сигнатур, рядом с которыми
находятся интересующие нас данные. Например, в тестовых дампах были найдены
следующие данные:

\begin{itemize}
  \item Секреты wordpress.\\
  NONCE\_SALT uk[* 4J5M)/wi~\#25XFu(uD3...\\
  AUTH\_SALT kP8\_d9\,f\}Ie|T\#*hCCKHCH1...
  \item Пользователь базы данных.\\
  DB\_USER mighty\_Manwe
  \item Имя базы данных.\\
  DB\_NAME sacred\_Arda
  \item Пароль базы данных.\\
  DB\_PASSWORD children\_of\_Iluvatar
  \item Глобальная конфигурация Apache.\\
  IncludeOptional conf-enabled/*.conf\\
  \# Include the virtual host configurations:\\
  IncludeOptional sites-enabled/*.conf\\
  \# vim: syntax=apache ts=4 sw=4 sts=4 sr noet\\
  CoreDumpDirectory /var/www/wordpress
  \item Конфигурация Apache для виртуального хоста.\\
  CustomLog \${APACHE\_LOG\_DIR}/access.log combined\\
  SSLEngine on\\
  SSLCertificateFile /etc/apache2/ssl/apache.crt\\
  SSLCertificateKeyFile /etc/apache2/ssl/apache.key\\
  </VirtualHost>
\end{itemize}

\subsubsection{Извлечение файлов с известными сигнатурами}

Для извлечения файлов с заданными сигнатурами можно использовать утилиту
binwalk \cite{binwalk}. Данная утилита сканирует данный файл, ищет известные
магические числа \cite{signatures}, например для jpg это \textbackslash xFF
\textbackslash xD8 \textbackslash xFF, а для pdf это \textbackslash x25
\textbackslash x50 \textbackslash x44 \textbackslash x46. После нахождения
известной сигнатуры, binwalk пытается извлечь весь файл по ней \ref{binwalk-example}.

\begin{lstlisting}[caption={Пример работы binwalk на дампе памяти},label={binwalk-example},breaklines]
DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             ELF, 64-bit LSB core file AMD x86-64, version 1 (SYSV)
31968         0x7CE0          Unix path: /usr/sbin/apache2 -k start
45100         0xB02C          Unix path: /usr/lib/x86_64-linux-gnu/libxslt.so.1.1.28
19535744      0x12A1780       Ubiquiti firmware header, third party, ~CRC32: 0x44415441, version: "SSL_CIPHER_AES_256_CBC"
19536088      0x12A18D8       Ubiquiti firmware header, third party, ~CRC32: 0x54555245, version: "SSL_TLSEXT_SERVER_NAME"
19612800      0x12B4480       Unix path: /var/www/wordpress/wp-blog-header.php
19614760      0x12B4C28       Unix path: /var/www/wordpress/
19633322      0x12B94AA       HTML document header
19633832      0x12B96A8       HTML document footer
19642449      0x12BB851       Unix path: /var/www/wordpress/wp-includes/compat.php0x7f46f4fec312
...
19767912      0x12DA268       XML document, version: "1.0"
...
37433704      0x23B3168       Unix path: /var/www/wordpress/wp-includes/formatting.php
37648994      0x23E7A62       Copyright string: "copyright November 4, 2001"
37859599      0x241B10F       HTML document footer
37859707      0x241B17B       HTML document header
37888488      0x24221E8       Unix path: /var/www/wordpress/wp-includes/capabilities.php
37940648      0x242EDA8       Unix path: /var/www/wordpress/wp-includes/class-wp-roles.php
207986779     0xC65A05B       Unix path: /usr/lib/apache2/modules/mod_authz_host.so
207990872     0xC65B058       Unix path: /etc/apache2/mods-enabled/authz_host.load
207992656     0xC65B750       Unix path: /etc/apache2/mods-enabled/authz_user.load
207994971     0xC65C05B       Unix path: /usr/lib/apache2/modules/mod_authz_user.so
\end{lstlisting}

Раскрывается структура файловой системы хоста и присутствуют некоторые части
HTML документов.

\newpage

\section{Экспериментальное исследование}

\subsection{Цель исследования}

Целью экспериментального исследования является проверка возможности извлечения
конфиденциальных данных из дампа памяти веб-сервера. В частности, проверка работы
утилиты по извлечению приватного ключа RSA, проверка наличия таких конфиденциальных
данных как логины, пароли, хеши паролей, части конфигурационных файлов и т.д. в
дампе памяти веб-сервера.

\subsection{Методика исследования}

\begin{itemize}
  \item Создаем чистую виртуальную машину с нужной версией операционной системы.
  \item На полученной машине устанавливаем все необходимые пакеты для работы
  веб-сервера и системы управления содержимым сайта (LAMP Stack, Linux, Apache,
  Mysql, PHP).
  \item Добавляем пользователей сервиса: рядового посетителя и администратора.
  \item Делаем несколько типовых для пользователя и администратора действий.
  \begin{itemize}
    \item Аутентификация.
    \item Чтение постов.
    \item Редактирование постов.
    \item Манипуляция сервисом (администратор).
  \end{itemize}
  \item Вызываем создание дампа памяти.
  \item Получаем один или несколько дампов памяти, в зависимости от настроек
  именования файла дампа памяти.
  \item Запускаем утилиту для анализа дампов памяти, которая ищет в дампе
  заранее заданные конфиденциальные данные.
  \item Сохраняем полученные результаты.
\end{itemize}

\subsection{Инструментарий}

Для воспроизводимости экспериментов нужна виртуальная машина или контейнер.
Манипуляции с ними можно проводить с помощью соответствующих утилит, но
удобный унифицированный интерфейс для этого предлагает инструмент Vagrant \cite{vagrant}.
Он позволяет создавать виртуальные машины и контейнеры с произвольной
операционной системой, а их начальное состояние задавать с помощью конфигурационного
файла.

Для установки необходимых программных пакетов и задания конфигурационных файлов
используется система управления конфигурациями Ansible \cite{ansible}. Она
позволяет детально задавать процесс установки программного обеспечения с помощью
конфигурационных файлов. При этом существует порядка 11 тысяч таких файлов для
разнообразных нужд, написанных пользователями Ansible \cite{ansible-galaxy},
что значительно упрощает процесс упрощает установки и настройки необходимого
прграммного обеспечения.

\subsection{Результаты}

\begin{table}[]
\caption{Результаты тестирования}
\label{results-label}
\begin{tabular}{|l|l|}
\hline
Эксперимент                                                                                     & Ubuntu trusty 64               \\  \hline
database name                                                                                   & +                              \\  \hline
database user                                                                                   & +                              \\  \hline
database password (plaintext)                                                                   & +                              \\  \hline
FTP user                                                                                        & +                              \\  \hline
FTP password (plaintext)                                                                        & +                              \\  \hline
wordpress user name                                                                             & + (присутствует не во всех дампах) \\  \hline
wordpress user password                                                                         & -                              \\  \hline
wordpress user passwords hash                                                                   & + (присутствует не во всех дампах) \\  \hline
wordpress user email                                                                            & + (присутствует не во всех дампах) \\  \hline
ssl private key                                                                                 & +                              \\  \hline
Client requests                                                                                 & + (присутствует не во всех дампах) \\  \hline
web pages (html/js/css)                                                                         & +- некоторые части html/js/css \\  \hline
Source code                                                                                     & -                              \\  \hline
process envrironment                                                                            & +                              \\  \hline
Apache (global) configs                                                                         & +                              \\  \hline
Apache (vhost) configs                                                                          & +                              \\  \hline
\begin{tabular}[c]{@{}l@{}}Wordpress secrets\\  (AUTH\_KEY, SECURE\_AUTH\_KEY, ...)\end{tabular} & +                              \\  \hline
\end{tabular}
\end{table}

Результаты полученные на операционной системе Ubuntu trusty приведены в
таблице \ref{results-label}. Результаты экспериментов на других операционных системах доступны по
\href{https://docs.google.com/spreadsheets/d/1LKtlXDnme2VMcUHvuBchA3CY6Ja6uCRp\_CwBd8Z1a0s/edit?usp=sharing}{cсылке}

\newpage

\section{Заключение}

Получение злоумышленником дампа памяти может привести к полной компрометации
веб-сервиса, так как дамп памяти может содержать различную конфиденциальную
информацию, такую как логины и пароли к FTP серверам или базам данных, а также
из дампа памяти может быть извлечен приватный ключ используемый веб-сервером.
Но при этом получение дампа памяти сопряжено с трудностями, так как веб-сервис
должен быть неправильно сконфигурирован или содержать уязвимости.

\newpage

\bibliography{bibliography}
\bibliographystyle{plainnat}

\end{document}
