\documentclass[20pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{url}
\usepackage[colorlinks,allcolors=blue]{hyperref}
\usepackage[numbers]{natbib}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage[outdir=./]{epstopdf}
\usepackage{listings}

\newtheorem*{mydef}{Определение}

\title{Дипломная работа}
\author{Козлов Никита}

\begin{document}

\thispagestyle{empty}

\begin{center}
\ \vspace{-4cm}

\includegraphics[width=0.5\textwidth]{msu}\\
{Московский государственный университет имени М.В.~Ломоносова}\\
Факультет вычислительной математики и кибернетики\\
Кафедра автоматизации систем вычислительных комплексов (АСВК)

\vspace{5cm}

{\Large Козлов~Никита~Вячеславович}

\vspace{1cm}

{\Large\bfseries
Извлечение данных о состоянии веб-приложения на основе анализа образа памяти веб-сервера\\}

\vspace{1cm}

{\large ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА}
\end{center}

\vfill

\begin{flushright}
  \textbf{Научный руководитель:}\\
  м.н.с. А.А.~Петухов
\end{flushright}

\vfill

\begin{center}
Москва, 2017
\end{center}

\enlargethispage{4\baselineskip}

\newpage

\section*{Аннотация}
Данная работа посвящена исследованию возможности извлечения конфиденциальных
данных из образа памяти веб-сервера. Для исследований и экспериментов
использовался веб-сервер Apache, а в качестве системы управления содержимым
сайта использовался Wordpress. На полученной системе были протестированы
различные методы извлечения приватного ключа и других конфиденциальных данных.

\newpage

\tableofcontents

\newpage

\section{Введение}

\subsection{Предметная область}
Веб-приложения играют значительную роль в жизни современного общества. С их
помощью люди могут оформлять документы, заказывать любые товары, покупать и
продавать ценные бумаги и многое другое. Для работы любого такого веб-приложения
необходим веб-сервер, который будет обслуживать всех клиентов.

(#TODO добавить инфы про веб-серверы)
(#TODO добавить инфы про wordpress)

Во время работы программы могут произойти различные ошибки\cite{error-types} \ref{errors}.
В целях выявления причин этих ошибок существуют дампы памяти.

\subsection{Дамп памяти}

Дамп памяти\cite{wiki/coredump} - это содержимое рабочей памяти процесса, его
формирует операционная система в случае, когда процесс завершается из-за
критической ошибки\cite{core-dump-signals}:
\begin{itemize}\label{errors}
  \item SIGFPE - скритичная ошибка в арифмитической операции
  \begin{itemize}
    \item деление на ноль
  \end{itemize}
  \item SIGILL - недопустимая инструкция
  \item SIGSEGV - ошибка доступа к памяти
    \begin{itemize}
      \item переполнение буфера\cite{buffer-overflow}
      \item переполнение стека\cite{stack-overflow}
      \item переполнение кучи\cite{heap-overflow}
      \item обращение на чтение или запись к области памяти для которой запрещены
      чтение или запись\cite{memory-corruption}
    \end{itemize}
  \item SIGBUS - разыменовывание недопустимого указателя
  \item SIGABRT - вызов функции abort
    \begin{itemize}
      \item освобождение ранее не выделенной памяти
    \end{itemize}
  \item SIGTRAP - достигнута точка останова
  \item SIGEMT - ошибка эмулятора
  \item SIGSYS - невалидный системный вызов
  \item SIGQUIT - критичная ситуация замеченная программой)\cite{sigquit}
\end{itemize}

Максимальный размер дампа памяти зависит от настроек операционной системы -
значения RLIMIT\_CORE. Размеры дампов памяти, полученных в тестовых условиях,
находятся в пределах нескольких сотен мегабайт, размер дампа памяти, полученного
на реальном сервере составляет 30Мб.

Дамп памяти может включать в себя значения регистров процессора, содержимое стека,
глобальные переменные, переменные окружения, локальные переменные и аргументы
функций во всех фреймах на момент создания дампа памяти и т.д. С его помощью
разработчик может посмотреть состояние программы на момент ошибки.

\begin{lstlisting}
> gdb -q \$(which apache2) core.apache2.23383
Reading symbols from /usr/sbin/apache2...Reading symbols from /usr/lib/debug//usr/sbin/apache2...done.
done.
[New LWP 23383]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Core was generated by `/usr/sbin/apache2 -k start'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007fbbfa5b957f in do_fcntl (arg=0x7fbbfa9f88e0, cmd=7, fd=14)
    at ../sysdeps/unix/sysv/linux/fcntl.c:39
(gdb) bt
#0  0x00007fbbfa5b957f in do_fcntl (arg=0x7fbbfa9f88e0, cmd=7, fd=14)
    at ../sysdeps/unix/sysv/linux/fcntl.c:39
#1  __libc_fcntl (fd=14, cmd=7) at ../sysdeps/unix/sysv/linux/fcntl.c:88
#2  0x00007fbbfa7e1296 in ?? () from /usr/lib/x86_64-linux-gnu/libapr-1.so.0
#3  0x00007fbbf79165a2 in accept_mutex_on () at prefork.c:232
#4  child_main (child_num_arg=child_num_arg@entry=4) at prefork.c:611
#5  0x00007fbbf79169a6 in make_child (s=0x7fbbfb310de0, slot=slot@entry=4) at prefork.c:800
#6  0x00007fbbf7916a06 in startup_children (number_to_start=1) at prefork.c:818
#7  0x00007fbbf79176e0 in prefork_run (_pconf=<optimized out>, plog=0x7fbbfb30c028,
    s=0x7fbbfb310de0) at prefork.c:976
#8  0x00007fbbfb0f19ce in ap_run_mpm (pconf=0x7fbbfb33f028, plog=0x7fbbfb30c028,
    s=0x7fbbfb310de0) at mpm_common.c:94
#9  0x00007fbbfb0eb1a6 in main (argc=3, argv=0x7fffb086f128) at main.c:777
(gdb) select-frame 8
(gdb) info args
pconf = 0x7fbbfb33f028
plog = 0x7fbbfb30c028
s = 0x7fbbfb310de0
(gdb) info locals
pHook = 0x7fbbfb27f660
n = 0
rv = -4
(gdb) select-frame 9
(gdb) info args
argc = 3
argv = 0x7fffb086f128
(gdb) quit
\end{lstlisting}

Для создания дампа памяти должны быть соблюдены следующую требования \cite{man/coredump}:
\begin{itemize}
  \item Процесс должен иметь права на запись файла. По умолчанию дамп памяти
  называется core и создается в рабочей папке приложения.
  \item Если существует файл с таким же именем с каким будет создан дамп памяти,
  то этот файл должен иметь не более одной жесткой ссылки(hard link)
  \item Дирректория в которой будет создан дамп памяти должна существовать.
  \item RLIMIT\_CORE и RLIMIT\_SIZE(максимальный размер файла) не должны быть равны 0
\end{itemize}

\subsection{Актуальность}
На 2 мая 2017 года 27.9\% сайтов работают под правлением Wordpress.
\cite{number_of_wordpress_sites}. На январь 2016 года, 33.56\% сайтов работали
на apache\cite{number_of_apache_sites}.

В экосистеме Wordpress(ядро, плагины, темы) было найдено как минимум 6892
уязвимостей\cite{wordpress/vulnerablilities-list-all}, из них 254
уязвимости\cite{wordpress/vulnerabilities-list-core} в ядре. В PHP было
найдено как минимум 538\cite{php/vulnerabilities-list} уязвимостей, а в apache
777\cite{apache/vulnerabilities-list}.

Некоторые из них позволяют вызывать выпадение дампа памяти, а некоторые дают
возможность его прочитать. При этом существует неправильно сконфигурированные
веб-сервера, которые позволяют читать файлы из корневой дирректории и
соотвествующих поддиректорий.

(\#TODO добавить про то, что таким способом уже была найдена корка)
(\#TODO добавить про отсутствие исследованией в данной области)

\newpage

\section{Цель работы и поставновка задачи}
Цель работы - исследовать возможность получения конфиденциальных данных из
дампа памяти веб-сервера.

\subsection{Постановка задачи}
На примере веб-сервера Apache и системы управления содержимым сайта Wordpress
исследовать возможность получения конфиденциальной информации из дампов памяти
веб-сервера. Для достижения поставленной цели необходимо:

\begin{itemize}
  \item Настроить тестовое окружение
  \item Ознакомиться с содержанием дампа памяти
  \item Ознакомиться с работами в предметной области
  \item Выяснить какие конфиденциальные данные встречаются в дампе памяти веб-сервера
  \item Разработать алгоритмы и подходы для извлечения конфиденциальных данных
\end{itemize}

\newpage

\section{Методы вызова создания дампа памяти}

Атакующий может создать дамп эксплуатируя ошибки, приводящие к экстренному
завершение работы веб-сервера. Вот примеры таких ошибок:
\begin{itemize} \cite{php-crash}
  \item  Бесконечная рекурсия
    \begin{itemize}
      \item Ошибка в библиотеке GD, когда конец рекурсии определяется на определенную
      структуру данного изображения. Специально сконструированное изображение вызовет
      переполнение буффера и экстренное завершение работы интерпретатора PHP.
    \end{itemize}
  \item Ошибки в библиотеках.
    \begin{itemize}
      \item Ошибки обработки заголовков. Существуют расширения PHP,такие как exif, GD,
        imagemagic, и другие, которые позволяют работать с изображениями. Для работы
        с изображениями необходимо выделить память, а необходимый объем определяется
        с помощью заголовков изображения. Таким образом выставляя специальные значения
        заголовков можно добиться экстренного заврешнения работы интерпретатора PHP.
    \end{itemize}
  \item Ошибки в различных встроенных функциях.
    \begin{itemize}
      \item CVE-2010-3710\cite{cve-2010-3710} когда использовалc режим
      FILTER\_VALIDATE\_EMAIL, злоумышленник мог вызвать отказ работы сервиса
      из-за использования большого объема памяти используя очень длинный почтовый адрес.
      \item Ошибка в функции pack(). Вызванная со специальными аргументами эта функция
        заставляет интерпретатор PHP выделить памяти больше чем есть на сервере, что
        вызовет экстренное завершение работы интерпретатора PHP.
    \end{itemize}
 \item Ошибки в коде дополнительных модулей.
 \item Многие другие ошибки.
\end{itemize}

\newpage

\section{Способы получения дампа памяти}

Атакующий может получить дамп памяти множеством способов:
\begin{itemize}
  \item При неправильной конфигурации веб-сервера становится возможным чтение
  файлов из поддирректорий корневой дирректории веб-сервиса\cite{directory-listing},
  куда может быть сохранен дамп памяти. Дирректория с дамами памяти задается
  диррективой CoreDumpDirectory в конфигурационных файлах веб-сервера apache.
  \item Открытый ftp сервер или ftp сервер с пользователем и паролем, которые
  легко перебрать.
  \item Directory traversal\cite{directory-traversal}
  \item XML external entity\cite{xxe} + php-wrapper\cite{php-wrappers}
  \item другие атаки и уязвимости
\end{itemize}

\newpage

\section{Конфиденциальные данные}

Во время работы веб-сервера в его оперативной памяти находятся различная
информация: данные последних запросов клиентов, приватные ключи, конфигурационные
файлы, логины и пароли от базы данных, конфигурационные данные и многое другое.
Это значит, что в оперативной памяти хранится различная конфиденциальная информация.

Конфиденциальные данные - данные, которые не подлежат разглашению. Перечислим
некоторые из них.

\begin{itemize}

  \item Cookies пользователя или их логины и пароли или хеши паролей. С их
  помощью можно получить неограниченный доступ к аккаунту жертвы.

  \item Конфигурационные файлы веб-сервера, исходные коды веб-сервиса и даже переменные
  окружения содержат информацию, которая может помочь атакующему найти и
  эксплуатировать различные уязвимости.

  \item Конфигурационные файлы веб-сервиса, которые могут содержать логины,
  пароли, токены для доступа к базам данных, FTP серверам и другим сервисам,
  попадание которых в руки злоумышленника может привести к раскрытию данных
  пользователей сервиса и компроментации самого сервиса.

  \item Для шифрования общения между клиентом и сервером используется криптографический
  протокол TLS\cite{tls} или его предшественник SSL. Для аутентификации сервера
  используются инфраструктура открытых ключей\cite{pki}. Одним из ключевых моментов
  инфраструктуры открытых ключей является то, что приватный ключ должен быть
  известен только владельцу сервера. Если злоумышленник сможет похитить приватный
  ключ, то он сможет осуществить атаку "Человек посередине"\cite{mitm}.

\end{itemize}


\subsection{Похожие исследования}

Heartbleed\cite{heartbleed} - критическая уязвимость в популярной криптографической
библиотеке OpenSSL. Эта уязвимость позволяла атакующему, пославшему специально
сформированный пакет, читать части оперативной памяти размером до 64КБ. Таким
образом атакующий мог подслушивать отрывки взаимодействия пользователей с сервисом.
Скомпрометированными могли оказаться приватные ключи, используемые для шифрования,
логины и пароли пользователей и другие конфиденциальные данные.

После того как была опубликована информация об уязвимости, компания cloudflare
провела собственное расследование\cite{heartbleed/investigation} целью которого
было выяснить, возможно ли извлечь приватный ключ из памяти веб-сервервера с
уязвимой версией OpenSSL. Во время этого расследования у инженеров компании не
получилось извлечь приватный ключ, но для того чтобы глубже изучить проблему
было организовано публичное соревнование\cite{hearbleed/investigation} с той же
самой целью. Каждый желающий мог попробовать извлечь приватный ключ из
данного веб-сервера с уязвимой версией OpenSSL.

Победителем данного соревнования стали Fedor Indutny\cite{heartbleed/Indutny} и
Ilkka Mattila через 9 часов с момента старта соревнования. Они успешно смогли
извлечь приватный ключ. Fedor смог получить ключ отправив около 2.5 миллионов
запросов, а у Ilkka получилось это сделать за 100 тысяч запросов.

По итогам соревнования coudflare рекомендовала всем перевыпустить все сертификаты
и ускорила перевыпуск сертификатов своих клиентов.(\#TODO проверить действительно
ли они выпускают сертификаты)

\subsection{Методы извлечения приватного ключа \cite{playing-hide-and-seek-with-stored-keys} }

\subsubsection{Введение}
В основу криптографической системы с открытым ключом RSA положена сложность задачи
факторизации произведения двух больших простых чисел. Для шифрования используется
операция возведения в степень по модулю большого числа. Для дешифрования за
разумное время необходимо уметь вычислять функцию Эйлера от данного большого
числа, для чего необходимо знать разложение числа на простые множители.(\#TODO
для подсчета функции Эйлера это не является необходимым условием)

Важные числа в криптографической системе rsa:
\begin{itemize}
  \item простые числа p и q
  \item их произведение $n=p \cdot q$, которое называется модулем
  \item значение функции Эйлера от числа n: $\varphi (n)=(p-1)\cdot (q-1)$.
  \item целое число e, которое называется открытой экспонентой
    (1<e<$\varphi$ (n)), взаимно простое со значением функции $\varphi(n)$.
  \item число d, мультипликативно обратное к числу e по модулю
    $\varphi$ (n), то есть число, удовлетворяющее сравнению: $d\cdot e\equiv 1{\pmod {\varphi (n)}}$.
\end{itemize}

\subsubsection{Исходные данные}
Известны n и e используемые в схеме RSA жертвы, их можно узнать из сертификата
жертвы, а также имеем строку длинны u - содержимое дампа памяти процесса
веб-сервера, для которой известно, что она содержит приватный ключ d как
последовательную запись длинны v бит. Обычно длинна u имеет порядок $10^10$,
а длинна v имеет порядок $10^3$.

\subsubsection{Алгоритм: последовательный перебор}
Простейший способ поиска приватного ключа, который применим ко всем
криптосистемам, заключается в том, чтобы получить пару открытый текст/шифротекст,
а затем сканировать данную последовательность и проводить попытки дешифровки
шифротекста используя как ключ каждую последовательность длинны v. (\#TODO рассказать,
как можно получить пару открытый текст/шифротекст)

Редкие ложноположительные результаты могут быть устранены проверкой
дополнительных пар текст/шифротекст.

Основной проблемой такого подхода является тот факт, что такие вычисления очень
ресурсоемкие, а сложность вычислений растет как куб от размера v модуля.
Перебор все подстрок длинны v в строке длинны u, дает сложность O(n*$v^3$),
конечно это полиномиальная сложность, но применять такой алгоритм на практике
очень ресурсоемко.

Проведя оптимизации, возможно снизить сложность до O(u). (\#TODO описать оптимизации)

\subsubsection{Алгоритм: поиск делителей}
Этот подход заключается в том, поиске в данной строке делители модуля n - p и q.
Несмотря на то, что в теории серверу нет необходимости хранить делители в
памяти, так как нужно посчитать лишь $m^d$(mod n), но почти во всех практических
реализациях RSA делители хранятся в памяти в целях оптимизации вычислений.

Допустимо сделать предположение, что p и q находятся в памяти сразу друг за другом,
и расстояние между их менее значимыми битами примерно v/2. Таким образом можно
умножать каждые 2 подряд идущих числа на расстоянии v/2 и сравнивать результат с
n. Таким образом сложность вычислений O(u*$v^2$).

С помощью дальнейших оптимизаций возможно добиться ускорения работы алгоритма
до O(n). (\#TODO описать оптимизации)

\subsubsection{Оптимизации: поиск мест с высокой энтропией}
Процесс поиска можно оптимизировать, если понять какими характеристиками обладает
объект поиска, и искать места с этими характеристиками. Большая часть кода и данных
формируется неслучайным образом, а криптографические ключи редко выбирается
неслучайно. Таким образом можно утверждать, что криптографические ключи находятся
в области с высокой энтропией.

(\#TODO добавить картинки с изображением мест с высокой энтропией)

\subsubsection{Оптимизации: анализ структур кода приложения}
Альтернативным способом нахождения приватного ключа является поиск структур
данных, специфичных для конкретного веб-сервера. Посмотрев структуру данных в которой
хранится приватный ключ, в данном случае это (\#TODO добавить имя файла со структурой
данных и саму структуру данных), будем искать в дампе памяти эту структуру данных
и пытаться расшифровать некоторое сообщение или найти делитель модуля.

Таким образом работает утилита passe-partout, которая может извлекать приватный ключ из
памяти работающего веб-приложения.

(\#TODO добавить инфы из доки про утилиту passe-partout)

\subsection{Извлечение других конфиденциальных данных}

\subsubsection{Извлечение логинов и паролей, конфигурационных файлов}
(\#TODO написать как искать логины, пароли, кукесы)

\subsubsection{Извлечение файлов с известными сигнатурами}
(\#TODO написать про то, как работает binwalk)

\newpage

\section{Тестирование}

\subsection{Методика тестирования}

\begin{itemize}
  \item Разворачиваем(\#TODO как?) чистую машину с нужной версией операционной системы
  \item На полученной машине устанавливаем все необходимые пакеты для работы
  веб-сервера и системы управления содержимым сайта(\#TODO рассказать про тулзы)
  \item Добавляем пользователей, рядового посетителя и администратора
  \item Делаем несколько типовых для пользователя и администратора действий
  \item Вызываем создание дампа памяти с помощью специального сигнала
  \item Получаем один или несколько дампов памяти, в зависимости от настроек
  веб-сервера
  \item Запускаем утилиту для анализа дампов памяти, которая ищет в дампе
  заранее заданные конфиденциальные данные.
  \item Сохраняем полученные результаты
\end{itemize}

\subsection{Результаты тестирования}
Результаты тестирования

\begin{table}[]
\centering
\caption{My caption}
\label{my-label}
\begin{tabular}{|l|l|l|}
\hline
Эксперимент                                                                                 & Ubuntu trusty 64               & Ubuntu xenial 64 \\ \hline
database name                                                                                   & +                              &                  \\ \hline
database user                                                                                   & +                              &                  \\ \hline
database password(plaintext)                                                                    & +                              &                  \\ \hline
ftp user                                                                                        & +                              &                  \\ \hline
ftp password(plaintext)                                                                         & +                              &                  \\ \hline
wordpress user name                                                                             & + (выпадает не во всех корках) &                  \\ \hline
wordpress user password                                                                         & -                              &                  \\ \hline
wordpress user passwords hash                                                                   & + (выпадает не во всех корках) &                  \\ \hline
wordpress user email                                                                            & + (выпадает не во всех корках) &                  \\ \hline
ssl private key                                                                                 & +                              &                  \\ \hline
Client requests                                                                                 & + (выпадают не во всех корках) &                  \\ \hline
web pages(html/js/css)                                                                          & +- некоторые части html/js/css &                  \\ \hline
Source code                                                                                     & -                              &                  \\ \hline
process envrironment                                                                            & +                              &                  \\ \hline
Apache(global) configs                                                                          & +                              &                  \\ \hline
Apache(vhost) configs                                                                           & +                              &                  \\ \hline
\begin{tabular}[c]{@{}l@{}}Wordpress secrets\\ (AUTH\_KEY, SECURE\_AUTH\_KEY, ...)\end{tabular} & -                              &                  \\ \hline
\end{tabular}
\end{table}
\newpage

\section{Заключение}
(\#TODO Заключение)

\newpage

\bibliography{bibliography}
\bibliographystyle{plainnat}

\end{document}
