\documentclass[20pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{url}
\usepackage[colorlinks,allcolors=blue]{hyperref}
\usepackage[numbers]{natbib}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage[outdir=./]{epstopdf}
\usepackage{listings}

\newtheorem*{mydef}{Определение}

\title{Дипломная работа}
\author{Козлов Никита}

\begin{document}

\thispagestyle{empty}

\begin{center}
\ \vspace{-4cm}

\includegraphics[width=0.5\textwidth]{msu}\\
{Московский государственный университет имени М.В.~Ломоносова}\\
Факультет вычислительной математики и кибернетики\\
Кафедра автоматизации систем вычислительных комплексов (АСВК)

\vspace{5cm}

{\Large Козлов~Никита~Вячеславович}

\vspace{1cm}

{\Large\bfseries
Извлечение данных о состоянии веб-приложения на основе анализа образа памяти веб-сервера\\ }

\vspace{1cm}

{\large ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА}
\end{center}

\vfill

\begin{flushright}
  \textbf{Научный руководитель:}\\
  м.н.с. А.А.~Петухов
\end{flushright}

\vfill

\begin{center}
Москва, 2017
\end{center}

\enlargethispage{4\baselineskip}

\newpage

\section*{Аннотация}
Данная работа посвящена исследованию возможности извлечения конфиденциальных
данных из образа памяти веб-сервера. Для исследований и экспериментов
использовался веб-сервер Apache, а в качестве системы управления содержимым
сайта использовался Wordpress. На полученной системе были протестированы
различные методы извлечения приватного ключа и других конфиденциальных данных.

\newpage

\tableofcontents

\newpage

\section{Введение}

\subsection{Предметная область}

Веб-приложения играют значительную роль в жизни современного общества. С их
помощью люди могут оформлять документы, заказывать любые товары, покупать и
продавать ценные бумаги и многое другое. Для работы любого такого веб-приложения
необходим веб-сервер, который будет обслуживать всех клиентов.

(\#TODO добавить инфы про веб-серверы)
(\#TODO добавить инфы про wordpress)

Во время работы программы могут произойти различные ошибки\cite{error-types} \ref{errors}.
В целях выявления причин этих ошибок существуют дампы памяти.

\subsection{Дамп памяти}

Дамп памяти\cite{wiki/coredump} - это содержимое рабочей памяти процесса, его
формирует операционная система в случае, когда процесс завершается из-за
критической ошибки\cite{core-dump-signals}:
\begin{itemize}\label{errors}
  \item SIGFPE - критичная ошибка в арифметической операции
  \begin{itemize}
    \item деление на ноль
  \end{itemize}
  \item SIGILL - недопустимая инструкция
  \item SIGSEGV - ошибка доступа к памяти
    \begin{itemize}
      \item переполнение буфера\cite{buffer-overflow}
      \item переполнение стека\cite{stack-overflow}
      \item переполнение кучи\cite{heap-overflow}
      \item обращение на чтение или запись к области памяти для которой запрещены
      чтение или запись\cite{memory-corruption}
    \end{itemize}
  \item SIGBUS - разыменовывание недопустимого указателя
  \item SIGABRT - вызов функции abort
    \begin{itemize}
      \item освобождение ранее не выделенной памяти
    \end{itemize}
  \item SIGTRAP - достигнута точка останова
  \item SIGEMT - ошибка эмулятора
  \item SIGSYS - невалидный системный вызов
  \item SIGQUIT - критичная ситуация замеченная программой)\cite{sigquit}
\end{itemize}

Максимальный размер дампа памяти зависит от настроек операционной системы -
значения RLIMIT\_CORE. Размеры дампов памяти, полученных в тестовых условиях,
находятся в пределах нескольких сотен мегабайт, размер дампа памяти, полученного
на реальном сервере составляет 30Мб.

Дамп памяти может включать в себя значения регистров процессора, содержимое стека,
глобальные переменные, переменные окружения, локальные переменные и аргументы
функций во всех фреймах на момент создания дампа памяти и т.д. С его помощью
разработчик может посмотреть состояние программы на момент ошибки.

\begin{lstlisting}
> gdb -q \$(which apache2) core.apache2.23383
Reading symbols from /usr/sbin/apache2...Reading symbols from /usr/lib/debug//usr/sbin/apache2...done.
done.
[New LWP 23383]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Core was generated by `/usr/sbin/apache2 -k start'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007fbbfa5b957f in do_fcntl (arg=0x7fbbfa9f88e0, cmd=7, fd=14)
    at ../sysdeps/unix/sysv/linux/fcntl.c:39
(gdb) bt
#0  0x00007fbbfa5b957f in do_fcntl (arg=0x7fbbfa9f88e0, cmd=7, fd=14)
    at ../sysdeps/unix/sysv/linux/fcntl.c:39
#1  __libc_fcntl (fd=14, cmd=7) at ../sysdeps/unix/sysv/linux/fcntl.c:88
#2  0x00007fbbfa7e1296 in ?? () from /usr/lib/x86_64-linux-gnu/libapr-1.so.0
#3  0x00007fbbf79165a2 in accept_mutex_on () at prefork.c:232
#4  child_main (child_num_arg=child_num_arg@entry=4) at prefork.c:611
#5  0x00007fbbf79169a6 in make_child (s=0x7fbbfb310de0, slot=slot@entry=4) at prefork.c:800
#6  0x00007fbbf7916a06 in startup_children (number_to_start=1) at prefork.c:818
#7  0x00007fbbf79176e0 in prefork_run (_pconf=<optimized out>, plog=0x7fbbfb30c028,
    s=0x7fbbfb310de0) at prefork.c:976
#8  0x00007fbbfb0f19ce in ap_run_mpm (pconf=0x7fbbfb33f028, plog=0x7fbbfb30c028,
    s=0x7fbbfb310de0) at mpm_common.c:94
#9  0x00007fbbfb0eb1a6 in main (argc=3, argv=0x7fffb086f128) at main.c:777
(gdb) select-frame 8
(gdb) info args
pconf = 0x7fbbfb33f028
plog = 0x7fbbfb30c028
s = 0x7fbbfb310de0
(gdb) info locals
pHook = 0x7fbbfb27f660
n = 0
rv = -4
(gdb) select-frame 9
(gdb) info args
argc = 3
argv = 0x7fffb086f128
(gdb) quit
\end{lstlisting}

Для создания дампа памяти должны быть соблюдены следующую требования \cite{man/coredump}:
\begin{itemize}
  \item Процесс должен иметь права на запись файла. По умолчанию дамп памяти
  называется core и создается в рабочей папке приложения.
  \item Если существует файл с таким же именем с каким будет создан дамп памяти,
  то этот файл должен иметь не более одной жесткой ссылки(hard link)
  \item Директория в которой будет создан дамп памяти должна существовать.
  \item RLIMIT\_CORE и RLIMIT\_SIZE(максимальный размер файла) не должны быть равны 0
\end{itemize}

\subsection{Актуальность}
На 2 мая 2017 года 27.9\% сайтов работают под правлением Wordpress.
\cite{number_of_wordpress_sites}. На январь 2016 года, 33.56\% сайтов работали
на apache\cite{number_of_apache_sites}.

В экосистеме Wordpress(ядро, плагины, темы) было найдено как минимум 6892
уязвимостей\cite{wordpress/vulnerablilities-list-all}, из них 254
уязвимости\cite{wordpress/vulnerabilities-list-core} в ядре. В PHP было
найдено как минимум 538\cite{php/vulnerabilities-list} уязвимостей, а в apache
777\cite{apache/vulnerabilities-list}.

Некоторые из них позволяют вызывать выпадение дампа памяти, а некоторые дают
возможность его прочитать. При этом существует неправильно сконфигурированные
веб-сервера, которые позволяют читать файлы из корневой директории и
соотвествующих поддиректорий.

(\#TODO добавить про то, что таким способом уже была найдена корка)
(\#TODO добавить про отсутствие исследованией в данной области)

\newpage

\section{Цель работы и постановка задачи}

Цель работы - исследовать возможность получения конфиденциальных данных из
дампа памяти веб-сервера.

\subsection{Постановка задачи}

На примере веб-сервера Apache и системы управления содержимым сайта Wordpress
исследовать возможность получения конфиденциальной информации из дампов памяти
веб-сервера. Для достижения поставленной цели необходимо:

\begin{itemize}
  \item Настроить тестовое окружение
  \item Ознакомиться с содержанием дампа памяти
  \item Ознакомиться с работами в предметной области
  \item Выяснить какие конфиденциальные данные встречаются в дампе памяти веб-сервера
  \item Разработать алгоритмы и подходы для извлечения конфиденциальных данных
\end{itemize}

\newpage

\section{Методы вызова создания дампа памяти}

Атакующий может создать дамп эксплуатируя ошибки, приводящие к экстренному
завершение работы веб-сервера. Вот примеры таких ошибок\cite{php-crash}:
\begin{itemize}
  \item  Бесконечная рекурсия
    \begin{itemize}
      \item Ошибка в библиотеке GD, когда конец рекурсии определяется на определенную
      структуру данного изображения. Специально сконструированное изображение вызовет
      переполнение буфера и экстренное завершение работы интерпретатора PHP.
    \end{itemize}
  \item Ошибки в библиотеках.
    \begin{itemize}
      \item Ошибки обработки заголовков. Существуют расширения PHP,такие как exif, GD,
        imagemagic, и другие, которые позволяют работать с изображениями. Для работы
        с изображениями необходимо выделить память, а необходимый объем определяется
        с помощью заголовков изображения. Таким образом выставляя специальные значения
        заголовков можно добиться экстренного завершнения работы интерпретатора PHP.
    \end{itemize}
  \item Ошибки в различных встроенных функциях.
    \begin{itemize}
      \item CVE-2010-3710\cite{cve-2010-3710} когда использовалc режим
      FILTER\_VALIDATE\_EMAIL, злоумышленник мог вызвать отказ работы сервиса
      из-за использования большого объема памяти используя очень длинный почтовый адрес.
      \item Ошибка в функции pack(). Вызванная со специальными аргументами эта функция
        заставляет интерпретатор PHP выделить памяти больше чем есть на сервере, что
        вызовет экстренное завершение работы интерпретатора PHP.
    \end{itemize}
 \item Ошибки в коде дополнительных модулей.
 \item Многие другие ошибки.
\end{itemize}

\newpage

\section{Способы получения дампа памяти}

Атакующий может получить дамп памяти множеством способов:
\begin{itemize}
  \item При неправильной конфигурации веб-сервера становится возможным чтение
  файлов из поддиректорий корневой директории веб-сервиса\cite{directory-listing},
  куда может быть сохранен дамп памяти. Директория с дамами памяти задается
  диррективой CoreDumpDirectory в конфигурационных файлах веб-сервера apache.
  \item Открытый ftp сервер или ftp сервер с пользователем и паролем, которые
  легко перебрать.
  \item Directory traversal\cite{directory-traversal}
  \item XML external entity\cite{xxe} + php-wrapper\cite{php-wrappers}
  \item другие атаки и уязвимости
\end{itemize}

(\#TODO добавить информации и подробностей)

\newpage

\section{Конфиденциальные данные}

Во время работы веб-сервера в его оперативной памяти находятся различная
информация: данные последних запросов клиентов, приватные ключи, конфигурационные
файлы, логины и пароли от базы данных, конфигурационные данные и многое другое.
Это значит, что в оперативной памяти хранится различная конфиденциальная информация.

Конфиденциальные данные - данные, которые не подлежат разглашению. Перечислим
некоторые из них.

\begin{itemize}

  \item Cookies пользователя или их логины и пароли или хеши паролей. С их
  помощью можно получить неограниченный доступ к аккаунту жертвы.

  \item Конфигурационные файлы веб-сервера, исходные коды веб-сервиса и даже переменные
  окружения содержат информацию, которая может помочь атакующему найти и
  эксплуатировать различные уязвимости.

  \item Конфигурационные файлы веб-сервиса, которые могут содержать логины,
  пароли, токены для доступа к базам данных, FTP серверам и другим сервисам,
  попадание которых в руки злоумышленника может привести к раскрытию данных
  пользователей сервиса и компроментации самого сервиса.

  \item Для шифрования общения между клиентом и сервером используется криптографический
  протокол TLS\cite{tls} или его предшественник SSL. Для аутентификации сервера
  используются инфраструктура открытых ключей\cite{pki}. Одним из ключевых моментов
  инфраструктуры открытых ключей является то, что приватный ключ должен быть
  известен только владельцу сервера. Если злоумышленник сможет похитить приватный
  ключ, то он сможет осуществить атаку "Человек посередине"\cite{mitm}.

\end{itemize}


\subsection{Похожие исследования}

Heartbleed\cite{heartbleed} - критическая уязвимость в популярной криптографической
библиотеке OpenSSL. Эта уязвимость позволяла атакующему, пославшему специально
сформированный пакет, читать части оперативной памяти размером до 64КБ. Таким
образом атакующий мог подслушивать части взаимодействия пользователей с сервисом.
Скомпрометированными могли оказаться приватные ключи, используемые для шифрования,
логины и пароли пользователей и другие конфиденциальные данные.

После того как была опубликована информация об уязвимости, компания cloudflare
провела собственное расследование\cite{heartbleed/investigation} целью которого
было выяснить, возможно ли извлечь приватный ключ из памяти веб-сервервера с
уязвимой версией OpenSSL. Во время этого расследования у инженеров компании не
получилось извлечь приватный ключ, но для того чтобы глубже изучить проблему
было организовано публичное соревнование\cite{hearbleed/investigation} с той же
самой целью. Каждый желающий мог попробовать извлечь приватный ключ из
данного веб-сервера с уязвимой версией OpenSSL.

Победителем данного соревнования стали Fedor Indutny\cite{heartbleed/Indutny} и
Ilkka Mattila через 9 часов с момента старта соревнования. Они успешно смогли
извлечь приватный ключ. Fedor смог получить ключ отправив около 2.5 миллионов
запросов, а у Ilkka получилось это сделать за 100 тысяч запросов.

По итогам соревнования coudflare рекомендовала всем перевыпустить все сертификаты
и ускорила перевыпуск сертификатов своих клиентов.

\subsection{Методы извлечения приватного ключа \cite{playing-hide-and-seek-with-stored-keys} }

\subsubsection{Введение}

В основу криптографической системы с открытым ключом RSA положена сложность задачи
факторизации произведения двух больших простых чисел. Для шифрования используется
операция возведения в степень по модулю большого числа. Для дешифрования за
разумное время необходимо уметь вычислять функцию Эйлера от данного большого
числа, для чего необходимо знать разложение числа на простые множители.

Важные числа в криптографической системе rsa:
\begin{itemize}
  \item простые числа p и q
  \item их произведение $n=p \cdot q$, которое называется модулем
  \item значение функции Эйлера от числа n: $\varphi (n)=(p-1)\cdot (q-1)$.
  \item целое число e, которое называется открытой экспонентой
    (1<e<$\varphi$ (n)), взаимно простое со значением функции $\varphi(n)$.
  \item число d, мультипликативно обратное к числу e по модулю
    $\varphi$ (n), то есть число, удовлетворяющее сравнению: $d\cdot e\equiv 1{\pmod {\varphi (n)}}$.
\end{itemize}

Пара {e, n} публикуется в качестве открытого ключа RSA .
Пара {d, n} играет роль закрытого ключа RSA и держится в секрете.

\subsubsection{Исходные данные}

Известны n и e используемые в схеме RSA жертвы, их можно узнать из сертификата
жертвы. Строка длинны u - содержимое дампа памяти процесса веб-сервера, для
которой известно, что она содержит приватный ключ d как последовательную запись
длинны v бит. Обычно v имеет порядок $10^3$.

\subsubsection{Алгоритм: последовательный перебор}

Простейший способ поиска приватного ключа, который применим ко всем
криптосистемам, заключается в том, чтобы получить пару открытый текст/шифротекст,
а затем сканировать данную последовательность и проводить попытки дешифровки
шифротекста используя как ключ каждую последовательность длинны v.

Пару открытый текст/шифротекст можем получить зашифровав некоторый открытый текст
публичным ключем.

Редкие ложноположительные результаты могут быть устранены проверкой
дополнительных пар текст/шифротекст.

Основной проблемой такого подхода является тот факт, что такие вычисления очень
ресурсоемкие, а сложность вычислений растет как куб от размера v модуля.
Перебор все подстрок длинны v в строке длинны u, дает сложность O(n*$v^3$),
конечно это полиномиальная сложность, но применять такой алгоритм на практике
очень ресурсоемко.

\subsubsection{Алгоритм: поиск делителей}

Этот подход заключается в том, поиске в данной строке делители модуля n - p и q.
Несмотря на то, что в теории серверу нет необходимости хранить делители в
памяти, так как нужно посчитать лишь $m^d$(mod n), но почти во всех практических
реализациях RSA делители хранятся в памяти в целях оптимизации вычислений.

Структура приватного ключа в библиотеке OpenSSL
\label{rsa}
\begin{lstlisting}
struct rsa_st
  {
  /* The first parameter is used to pickup errors where
   * this is passed instead of aEVP_PKEY, it is set to 0 */
  int pad;
  long version;
  const RSA_METHOD *meth;
  /* functional reference if 'meth' is ENGINE-provided */
  ENGINE *engine;
  BIGNUM *n;
  BIGNUM *e;
  BIGNUM *d;
  BIGNUM *p;
  BIGNUM *q;
  BIGNUM *dmp1;
  BIGNUM *dmq1;
  BIGNUM *iqmp;
  /* be careful using this if the RSA structure is shared */
  CRYPTO_EX_DATA ex_data;
  int references;
  int flags;

  /* Used to cache montgomery values */
  BN_MONT_CTX *_method_mod_n;
  BN_MONT_CTX *_method_mod_p;
  BN_MONT_CTX *_method_mod_q;

  /* all BIGNUM values are actually in the following data, if it is not
   * NULL */
  char *bignum_data;
  BN_BLINDING *blinding;
  BN_BLINDING *mt_blinding;
  };
\end{lstlisting}

Где BIGNUM это:
\begin{lstlisting}
  struct bignum_st
  {
  BN_ULONG *d;    /* Pointer to an array of 'BN_BITS2' bit chunks. */
  int top;    /* Index of last used d +1. */
  /* The next are internal book keeping for bn_expand. */
  int dmax;    /* Size of the d array. */
  int neg;    /* one if the number is negative */
  int flags;
  };
\end{lstlisting}

Видим, что делители n хранятся в памяти, а поле d структуры BIGNUM указывает на
значение числа.

\subsubsection{Алгоритм: анализ структур кода приложения}

Альтернативным способом нахождения приватного ключа является поиск структур
данных, специфичных для конкретного веб-сервера. Посмотрев структуру данных в которой
хранится приватный ключ\ref{rsa}, будем искать в дампе памяти эту структуру данных
и пытаться расшифровать некоторое сообщение или найти делитель модуля.

Таким образом работает утилита passe-partout\cite{passe-partout}, которая может извлекать приватный ключ из
памяти работающего веб-приложения.

\subsubsection{Оптимизации: поиск мест с высокой энтропией}

Процесс поиска можно оптимизировать, если понять какими отличительными
характеристиками обладает объект поиска, и искать места с этими характеристиками.
Большая часть кода и данных формируется неслучайным образом, а криптографические
ключи редко выбирается неслучайно. Таким образом можно утверждать, что
криптографические ключи находятся в области с высокой энтропией.

\subsection{Извлечение других конфиденциальных данных}

\subsubsection{Извлечение логинов и паролей, конфигурационных файлов}

Изучив тестовые дампы памяти можно составить список сигнатур, рядом с которыми
находятся интересующие нас данные. Например в тестовых дампах были найдены следующие
данные:

\begin{itemize}
  \item секреты wordpress

  NONCE\_SALT uk[* 4J5M)/wi~\#25XFu(uD3...

  AUTH\_SALT kP8\_d9\,f\}Ie|T\#*hCCKHCH1...

  \item пользователь базы данных

  DB\_USER mighty\_Manwe

  \item имя базы данных

  DB\_NAME sacred\_Arda

  \item пароль базы данных

  DB\_PASSWORD children\_of\_Iluvatar

  \item глобальная конфигурация Apache

  IncludeOptional conf-enabled/*.conf

  \# Include the virtual host configurations:

  IncludeOptional sites-enabled/*.conf

  \# vim: syntax=apache ts=4 sw=4 sts=4 sr noet

  CoreDumpDirectory /var/www/wordpress

  \item конфигурация Apache для виртуального хоста

  CustomLog \${APACHE\_LOG\_DIR}/access.log combined

  SSLEngine on

  SSLCertificateFile /etc/apache2/ssl/apache.crt

  SSLCertificateKeyFile /etc/apache2/ssl/apache.key

  </VirtualHost>

\end{itemize}

\subsubsection{Извлечение файлов с известными сигнатурами}

Для извлечения файлов с заданными сигнатурами можно использовать утилиту
binwalk\cite{binwalk}. Данная утилита сканирует данный файл, ищет известные
магические числа\cite{signatures}, например для jpg это \textbackslash xFF \textbackslash xD8 \textbackslash xFF,
а для pdf это \textbackslash x25 \textbackslash x50 \textbackslash x44 \textbackslash x46. После нахождения известной сигнатуры,
binwalk пытается извлечь весь файл по ней.

\begin{lstlisting}
DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             ELF, 64-bit LSB core file AMD x86-64, version 1 (SYSV)
31968         0x7CE0          Unix path: /usr/sbin/apache2 -k start
45100         0xB02C          Unix path: /usr/lib/x86_64-linux-gnu/libxslt.so.1.1.28
19535744      0x12A1780       Ubiquiti firmware header, third party, ~CRC32: 0x44415441, version: "SSL_CIPHER_AES_256_CBC"
19536088      0x12A18D8       Ubiquiti firmware header, third party, ~CRC32: 0x54555245, version: "SSL_TLSEXT_SERVER_NAME"
19612800      0x12B4480       Unix path: /var/www/wordpress/wp-blog-header.php
19614760      0x12B4C28       Unix path: /var/www/wordpress/
19633322      0x12B94AA       HTML document header
19633832      0x12B96A8       HTML document footer
19642449      0x12BB851       Unix path: /var/www/wordpress/wp-includes/compat.php0x7f46f4fec312
...
19767912      0x12DA268       XML document, version: "1.0"
...
37433704      0x23B3168       Unix path: /var/www/wordpress/wp-includes/formatting.php
37648994      0x23E7A62       Copyright string: "copyright November 4, 2001"
37859599      0x241B10F       HTML document footer
37859707      0x241B17B       HTML document header
37888488      0x24221E8       Unix path: /var/www/wordpress/wp-includes/capabilities.php
37940648      0x242EDA8       Unix path: /var/www/wordpress/wp-includes/class-wp-roles.php
207986779     0xC65A05B       Unix path: /usr/lib/apache2/modules/mod_authz_host.so
207990872     0xC65B058       Unix path: /etc/apache2/mods-enabled/authz_host.load
207992656     0xC65B750       Unix path: /etc/apache2/mods-enabled/authz_user.load
207994971     0xC65C05B       Unix path: /usr/lib/apache2/modules/mod_authz_user.so
\end{lstlisting}

Видим, что раскрывается структура файловой системы хоста и есть возможность извлечь
некоторые части HTML документов.

\newpage

\section{Тестирование}

\subsection{Методика тестирования}

\begin{itemize}
  \item Разворачиваем чистую виртуальную машину с нужной версией операционной системы.
  \item На полученной машине устанавливаем все необходимые пакеты для работы
  веб-сервера и системы управления содержимым сайта(LAMP Stack, Linux, Apache,
  Mysql, PHP).
  \item Добавляем пользователей сервиса: рядового посетителя и администратора.
  \item Делаем несколько типовых для пользователя и администратора действий.
  \begin{itemize}
    \item Аутентификация
    \item Чтение постов
    \item Редактирование постов
    \item Манипуляция сервисом(администратор)
  \end{itemize}
  \item Вызываем создание дампа памяти.
  \item Получаем один или несколько дампов памяти, в зависимости от настроек
  именования файла дампа памяти.
  \item Запускаем утилиту для анализа дампов памяти, которая ищет в дампе
  заранее заданные конфиденциальные данные.
  \item Сохраняем полученные результаты
\end{itemize}

\subsection{Результаты тестирования}

\begin{table}[]
\centering
\caption{Результаты тестирования}
\label{my-label}
\begin{tabular}{|l|l|}
\hline
Эксперимент                                                                                     & Ubuntu trusty 64               \\  \hline
database name                                                                                   & +                              \\  \hline
database user                                                                                   & +                              \\  \hline
database password(plaintext)                                                                    & +                              \\  \hline
ftp user                                                                                        & +                              \\  \hline
ftp password(plaintext)                                                                         & +                              \\  \hline
wordpress user name                                                                             & + (выпадает не во всех дампах) \\  \hline
wordpress user password                                                                         & -                              \\  \hline
wordpress user passwords hash                                                                   & + (выпадает не во всех дампах) \\  \hline
wordpress user email                                                                            & + (выпадает не во всех дампах) \\  \hline
ssl private key                                                                                 & +                              \\  \hline
Client requests                                                                                 & + (выпадают не во всех дампах) \\  \hline
web pages(html/js/css)                                                                          & +- некоторые части html/js/css \\  \hline
Source code                                                                                     & -                              \\  \hline
process envrironment                                                                            & +                              \\  \hline
Apache(global) configs                                                                          & +                              \\  \hline
Apache(vhost) configs                                                                           & +                              \\  \hline
\begin{tabular}[c]{@{}l@{}}Wordpress secrets\\  (AUTH\_KEY, SECURE\_AUTH\_KEY, ...)\end{tabular} & +                              \\  \hline
\end{tabular}
\end{table}
\newpage

\section{Заключение}

Получение злоумышленником дампа памяти может привести к полной компрометации
веб-сервиса, так как дамп памяти может содержать различную конфиденциальную
информацию, такую как логины и пароли к FTP серверам или базам данных, а также
из дампа памяти может быть извлечен приватный ключ используемый веб-сервером.
Но при этом получение дампа памяти сопряжено с трудностями, так как - веб-сервер
жертвы должен быть неправильно сконфигурирован или содержать уязвимости.

\newpage

\bibliography{bibliography}
\bibliographystyle{plainnat}

\end{document}
