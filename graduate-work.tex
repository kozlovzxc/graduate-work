\documentclass[20pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{url}
\usepackage[colorlinks,allcolors=blue]{hyperref}
\usepackage[numbers]{natbib}
\usepackage{amsthm}

\newtheorem*{mydef}{Определение}

\title{Дипломная работа}
\author{Козлов Никита}

\begin{document}

{\huge Извлечение данных о состоянии веб-приложения на основе анализа образа памяти веб-сервера}

\newpage

\section*{Аннотация}
Данная работа посвящена исследованию возможности извлечения конфиденциальных
данных из слепков памяти веб сервера. Для исследований и экспериментов
использовался веб сервер Apache, а в качестве системы управления содержимым
сайта использовался Wordpress. На полученной системе были протестированы
различные методы извлечения приватных ключей и других конфиденциальных данных.

\newpage

\tableofcontents

\newpage

\section{Введение}

\subsection{Предметная область}
Веб приложения играют значительную роль в жизни современного общества. С их помощью
люди могут оформлять документы, заказывать любые товары, покупать и продавать ценные
бумаги и многое другое. Для работы любого такого веб приложения необходим веб сервер,
который будет обслуживать всех клиентов. Веб сервер - это обычная программа, а во
всех программах случаются ошибки и эти ошибки нужно отлаживать. В целях выявления
причин ошибок существуют дампы памяти.

Дамп памяти - это содержимое рабочей памяти процесса, который формирует операционная
система, в случае, когда процесс завершается из-за критической ошибки, например
из-за ошибки сегментации(SIGSEGV). Также дамп можно сохранить вручную через отладчик
или самому послав специальный сигнал процессу. Размер дампа памяти зависит от настроек
операционной системы, в среднем, его размер составляет несколько гигабайт. Дамп
памяти может включать в себя значения регистров процессора, содержимое стека и
многое другое. С его помощью разработчик может посмотреть состояние программы
на момент ошибки. Например с помощью отладчика мы можем посмотреть состояние
переменных во всех функциях во всем стеке вызовов.

Во время работы веб сервера ему приходится держать в памяти многие вещи, такие
как данные последних запросов клиентов, приватные ключи, логины и пароли от базы
данных, конфигурационные данные и многое другое. Таким образом дамп памяти
хранит в себе различную конфиденциальную информацию.

Дамп памяти может быть получен множеством способов, например при неправильной
конфигурации веб сервера становится возможным чтение файлов из корневой
директории веб приложения, таким образом атакующий может его просто скачать.
Альтернативным способом получения дампа памяти является эксплуатация уязвимости
Local File Inclusion, которая позволяет читать произвольный файл в системе, и т.д.

\subsection{Актуальность}
\# todo посмотреть сколько веб серверов имеют неправильную конфигурацию
\# разрешающую читать произвольные файлы из корня

Большое количество неправильно сконфигурированных веб серверов, и частота различных
взломов говорит о том, что высока вероятность того, что атакующий сможет получить
доступ к дампам памяти.

Во время тестов на проникновение было бы крайне полезно извлекать конфиденциальную
информацию, но на данный момент отсутствуют утилиты помогающие в этом.

\newpage

\section{Цель работы}
Исследовать возможность получения конфиденциальной информации из дампов памяти веб сервера.

\newpage

\section{Постановка задачи}
На примере веб сервера Apache и системы управления содержимым сайта Wordpress
исследовать возможность получения конфиденциальной информации из дампов памяти
веб сервера.

\newpage

\section{Конфиденциальные данные}
Конфиденциальные данные - данные, которые не подлежат разглашению.

Примеры конфиденциальных данных которыми оперирует веб сервер:

\begin{itemize}
  \item cookies пользователей
  \item логины, пароли или хэши паролей пользователей
  \item конфигурационные файлы веб сервера
  \item конфигурационные файлы веб сервиса
  \item логины и пароли для доступа к базам данных
  \item логины и пароли для доступа к FTP сервер
  \item приватный ключ веб сервиса
  \item исходные коды веб сервиса
  \item переменные окружения веб сервера
  \item ...
\end{itemize}

\subsection{Похожие исследования}
Heartbleed - критическая уязвимость в популярной криптографической библиотеке
OpenSSL. Эта уязвимость позволяла атакующему, пославшему специально сформированный
пакет, читать части оперативной памяти размером до 64КБ. Таким образом атакующий
мог подслушивать взаимодействие пользователей с сервисом. Скомпроментироваными
могли оказаться приватные ключи, используемые для шифрования, логини и пароли
пользователей и другие конфиденциальные данные.

После того как была опубликована информация о уязвимости, компания cloudflare
провела собственное расследование целью которого было выяснить, возможно ли извлечь
приватный ключ из памяти веб сервервера с уязвимой версией OpenSSL. Во время этого
расследования у инженеров компании не получилось извлечь приватный ключ, но для
того чтобы глубже изучить проблему было организовано публичное соревнование с той
же самой целью. Каждый желающий мог попробовать извель приватный ключ из
предоставленного веб сервера с уязвимой версией OpenSSL.

Победителем данного соревнования стали Fedor Indutny и Ilkka Mattila после 9 часов
с момента старта соревнования. Они успешно смогли извлечь приватный ключ. Fedor
смог получить ключ отправив около 2.5 миллионов запросов, а у Ilkka получилось
это сделать за 100 тысяч запросов.

По итогам соревнования coudfare рекомендовала всем перевыпустить все сертификаты
и ускорила перевыпуск сертификатов своих клиентов.

\subsection{Методы извлечения приватного ключа \cite{playing-hide-and-seek-with-stored-keys} }
\subsubsection{Введение}
В этой части мы затронем проблемы эффективного извлечения криптографических
ключей в большом объеме данных.

В основу криптографической системы с открытым ключом RSA положена сложность задачи
факторизации произведения двух больших простых чисел. Для шифрования используется
операция возведения в степень по модулю большого числа. Для дешифрования за
разумное время необходимо уметь вычислять функцию Эйлера от данного большого
числа, для чего необходимо знать разложение числа на простые множители.

Важные числа в криптографической системе rsa:
\begin{itemize}
  \item простые числа p и q
  \item их произведение $n=p \cdot q$, которое называется модулем
  \item значение функции Эйлера от числа n: $\varphi (n)=(p-1)\cdot (q-1)$.
  \item целое число e, которое называется открытой экспонентой
    (1<e<$\varphi$ (n)), взаимно простое со значением функции $\varphi(n)$.
  \item число d, мультипликативно обратное к числу e по модулю
    $\varphi$ (n), то есть число, удовлетворяющее сравнению: $d\cdot e\equiv 1{\pmod {\varphi (n)}}$.
\end{itemize}

\subsubsection{Исходные данные}
Предполагается, что мы знаем n и e используемые в схеме RSA жертвы, мы можем
узнать их из сертификата жертвы, а также имеем строку длинны u(содержимое дампа
памяти процесса веб сервера), для которой известно, что она содержит приватный
ключ d как последовательная запись длинны v бит. Обычно длинна u имеет порядок
$10^10$, а длинна v имеет порядок $10^3$.

\subsubsection{Алгоритм: перебор}
Простейший способ поиска приватного ключа, который применим ко всем
криптосистемам, заключается в том, чтобы получить пару открытый текст/шифртекст,
а затем сканировать данную последовательность и проводить последовательные попытки
дешифровки шифротекста используя как ключ каждую последовательность длинны v.

Редкие ложноположительные результаты могут быть устранены проверкой
дополнительных пар.

Основной проблемой такого подхода является тот факт, что такие вычисления очень
ресурсоемкие, а сложность вычислений растет как куб от размера v модуля. Если мы
хотим попробовать все подстроки длинны v в строке длинны u, то получаем сложность
O(n*$v^3$), конечно это полиномиальная сложность, но применять такой алгоритм
на практике очень ресурсоемко.

Проведя оптимизации мы можем снизить сложность до O(u).

\subsubsection{Алгоритм: поиск делителей}
Этот подход заключается в том, чтобы искать в данной строке делители модуля n,
p и q. Несмотря на то, что в теории серверу нет необходимости хранить делители в
памяти, так как нужно посчитать лишь $m^d$(mod n), но почти во всех практических
реализациях RSA делители хранятся в памяти в целях оптимизации вычислений.

Можно сделать предположение, что p и q находятся в памяти сразу друг за другом,
и расстояние между их менее значимыми битами примерно v/2. Таким образом мы можем
умножать каждые 2 подряд идущих числа на расстоянии v/2 и сравнивать результат с
n. Таким образом сложность вычислений O(u*$v^2$). С помощью дальнейших оптимизаций
мы можем добиться ускорения работы алгоритма до O(n).

\subsubsection{Алгоритм: поиск мест с высокой энтропией}
Процесс поиска можно оптимизировать, если понять какими характеристиками обладает
объект поиска, и искать места с этими характеристиками. Большая часть кода и данных
формируется неслучайным образом, а для криптографические ключи редко выбирается
неслучайно. Таким образом мы можем быть уверены, что криптографические ключи находятся
в области с высокой энтропией.

\subsubsection{Алгоритм: анализ структур кода приложения}
Альтернативным способом нахождения приватного ключа является поиск структур
данных, специфичных для конкретного веб сервера. Посмотрев структуру данных в которой
хранится приватный ключ, в данном случае это *paste filename here*, будем искать
в дампе памяти эту структуру данных и пытаться расшифровать некоторое сообщение
или найти делитель модуля. Таким образом работает утилита passe-partout, которая
может извлекать приватный ключ из памяти работающего веб приложения.

\subsubsection{Способы сокрытия приватных ключей}
\# добавить что-нибудь?

\newpage

\section{Тестирование}

\subsection{Цель тестирования}

\subsection{Методика тестирования}

\begin{itemize}
  \item Разворачиваем чистую машину с нужной версией операционной системы
  \item На полученной машине устанавливаем все необходимые пакеты для работы
  веб сервера и системы управления содержимым сайта
  \item Добавляем пользователей, рядового посетителя и администратора
  \item Делаем несколько типовых для пользователя и администратора действий
  \item Вызываем создание дампа памяти с помощью специального сигнала
  \item Получаем один или несколько дампов памяти, в зависимости от настроек
  веб сервера
  \item Запускаем утилиту для анализа дампов памяти, которая ищет в дампе
  заранее заданные конфиденциальные данные.
  \item Сохраняем полученные результаты
\end{itemize}

\subsection{Результаты тестирования}
Результаты тестирования

\newpage

\section{Заключение}
Заключение

\bibliography{bibliography}
\bibliographystyle{plainnat}

\end{document}
