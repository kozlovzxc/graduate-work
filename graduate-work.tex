\documentclass[20pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{url}
\usepackage[colorlinks,allcolors=blue]{hyperref}
\usepackage[numbers]{natbib}
\usepackage{amsthm}

\newtheorem*{mydef}{Определение}

\title{Дипломная работа}
\author{Козлов Никита}

\begin{document}

{\huge Извлечение данных о состоянии веб-приложения на основе анализа образа памяти веб-сервера}

\newpage

\section*{Аннотация}
Данная работа посвящена исследованию возможности извлечения конфиденциальных данных из слепков памяти веб сервера. Для исследований и экспериментов использовался веб сервер Apache, а в качестве системы управления содержимым сайта использовался Wordpress. На полученной системе были протестированы
различные методы извлеченя приватных ключей и других конфиденциальных данных.

\newpage

\tableofcontents

\newpage

\section{Введение}

\subsection{Предметная область}
Для работы любого веб приложения необходим веб сервер, который будет обслуживать
всех клиентов. Веб сервер это обычная программа, так что на данный момент мы можем
абстрагироваться от предназначения данной программы и поговорить о том, что такое
дампы памяти.

Дамп памяти - это содержимое рабочей памяти процесса. Он может включать в себя
значения регистров процессора, содержимое стека и многое другое. Дамп памяти
необходим для отладки программы, так как с помощью него разработчик
может посмотреть состотяние программы на момент ошибки. С помощью отладчика мы
можем посмотреть состояние переменных во всех функциях во всем стеке вызовов.

Во время работы веб сервера ему приходится держать в памяти многие вещи, такие
как данные последних запросов клиентов, приватные ключи, логины и пароли от базы
данных, конфигурационные данные и многое другое. Таким образом дамп памяти
хранит в себе различную конфиденцеальную информацию.

Дамп памяти может быть получен множеством способов, например при неправильной
конфигурации веб сервера становится возможным чтение файлов из корневой
дирректории веб приложения, таким образом атакующий может его просто скачать,
другим спобом получения дампа памяти является эксплуатация уязвимости Local File
Read, которая позволяет читать произвольный файл в системе, и т.д.

Как правило дамп памяти процесса сохраняется автоматически, когда процесс
завершается из-за критической ошибки(например, из-за ошибки сегментации).

Также дамп можно сохранить вручную через отладчик или послав специальный сигнал
процессу.

\subsection{Актуальность}
Большое количество неправильно сконфигурированных серверов говорит о том, что
существует реальная возможность того, что атакующие обратят внимание на данную
проблему. Также не было найдено утилит, которые позволяют извлекать
конфиденциальные данные из дампа памяти веб сервера, или исследований о том,
какую информацию можно найти в слепках памяти.

\newpage

\section{Цель работы}
Исследовать возможность получения конфиденциальной информации из дампов памяти веб сервера.

\newpage

\section{Постановка задачи}
На примере веб сервера Apache и сисемы управления содержимым сайта Wordpress
исследовать возможность получения конфиденциальной информации из дампов памяти
веб сервера.

\newpage

\section{Конфиденциальные данные}
Конфиденциальные данные - данные, которые не подлежат разглашению.

\begin{itemize}
  \item cookies пользователей
  \item логины и пароли(хэши паролей) пользователей
  \item конфигурационные файлы веб сервреа
  \item конфигурационные файлы веб сервиса
  \item логины и пароли для доступа к базам данных
  \item логины и пароли для доступа к FTP сервер
  \item приватный ключ веб сервиса
  \item исходные коды веб сервиса
  \item переменные окружения веб сервера
  \item ...
\end{itemize}

\subsection{Методы извлечения приватного ключа \cite{playing-hide-and-seek-with-stored-keys} }
\subsubsection{Введение}
В этой части мы затронем проблемы эффективного извлечения криптографических
ключей в большом объеме данных.

\subsubsection{RSA}
Криптографические системы с открытым ключом используют так называемые односторонние функции, которые обладают следующим свойством:

\begin{itemize}
  \item Если известно x, то f(x) вычислить относительно просто
  \item Если известно y=f(x), то для вычисления x нет простого (эффективного) пути.
\end{itemize}

Под односторонностью понимается не теоретическая однонаправленность, а практическая невозможность вычислить обратное значение, используя современные вычислительные средства, за обозримый интервал времени.

В основу криптографической системы с открытым ключом RSA положена сложность задачи факторизации произведения двух больших простых чисел. Для шифрования используется операция возведения в степень по модулю большого числа. Для дешифрования (обратной операции) за разумное время необходимо уметь вычислять функцию Эйлера от данного большого числа, для чего необходимо знать разложение числа на простые множители.

В криптографической системе с открытым ключом каждый участник располагает как открытым ключом (англ. public key), так и закрытым ключом (англ. private key). В криптографической системе RSA каждый ключ состоит из пары целых чисел. Каждый участник создаёт свой открытый и закрытый ключ самостоятельно. Закрытый ключ каждый из них держит в секрете, а открытые ключи можно сообщать кому угодно или даже публиковать их. Открытый и закрытый ключи каждого участника обмена сообщениями в криптосистеме RSA образуют «согласованную пару» в том смысле, что они являются взаимно обратными, то есть:

 $\forall$  допустимых пар открытого и закрытого ключей  (p,s)
  соответствующие функции шифрования $E_{p}(x)$ и расшифрования $D_{s}(x)$ такие, что
 $\forall$  сообщений  m $\in$ M, где  M — множество допустимых сообщений, $m=D_{s}(E_{p}(m))=E_{p}(D_{s}(m))$.


RSA-ключи генерируются следующим образом:
\begin{itemize}
  \item Выбираются два различных случайных простых числа  p и  q заданного размера (например, 1024 бита каждое).
  \item Вычисляется их произведение  $n=p\cdot q$, которое называется модулем.
  \item Вычисляется значение функции Эйлера от числа  n: $\varphi (n)=(p-1)\cdot (q-1)$.
  \item Выбирается целое число  e (  1<e<$\varphi$ (n)), взаимно простое со
  значением функции $\varphi$ (n). Обычно в качестве  e берут простые числа,
  содержащие небольшое количество единичных бит в двоичной записи, например,
  простые числа Ферма 17, 257 или 65537.
  \begin{itemize}
    \item Число e называется открытой экспонентой (англ. public exponent)
    \item Время, необходимое для шифрования с использованием быстрого возведения
    в степень, пропорционально числу единичных бит в e.
    \item Слишком малые значения e, например 3, потенциально могут ослабить
    безопасность схемы RSA.
  \end{itemize}
  \item Вычисляется число  d, мультипликативно обратное к числу  e по модулю
  $\varphi$ (n), то есть число, удовлетворяющее сравнению: $d\cdot e\equiv 1{\pmod {\varphi (n)}}$.
  \begin{itemize}
    \item Число  d называется секретной экспонентой. Обычно, оно вычисляется при помощи расширенного алгоритма Евклида.
  \end{itemize}
  \item Пара $\left\{e,n\right\}$ публикуется в качестве открытого ключа RSA (англ. RSA public key).
  \item Пара $\left\{d,n\right\}$ играет роль закрытого ключа RSA (англ. RSA private key) и держится в секрете.
\end{itemize}


\subsubsection{Исходные данные}
Предполагается, что мы знаем n(modulus) и e(exponent) используемые схеме RSA
жертвы, которые мы можем узнать из сертификата жертвы, а также имеем строку
длинны u(содержимое дампа памяти процесса веб сервера), для которой известно,
что она содержит приватный ключ d как последовательная запись длинны v бит.
Обычно длинна u имеет порядок pow(10,10), а длинна v имеет порядок pow(10,3).

\subsubsection{Перебор}
Простейший способ поиска приватного ключа, который применим ко всем
криптосистемам, заключается в том, чтобы получить пару открытый текст/шифртекст,
а затем сканировать данную последовательност и проводить последовательные попытки
дешифровки шифротекста используя как ключ каждую последовательность длинны v.

Редкие ложноположительные результаты могут быть устраненны проверкой
дополнительных пар.

Основной проблемой такого подхода является тот факт, что такие вычисления очень
ресурсоемкие, а сложность вычислений растет как куб от размера v модуля. Если мы
хотим попробовать все подстроки длинны v в строке длинны u, то получаем сложность
O(n*pow(v,3)), конечно это полиномиальная сложность, но применять такой алгоритм
не практично.

Проведя оптимизации мы можем снизить сложность до O(n*pow(v,2)), что лучше, но
все еще довольно медленно.

Дальнейшие оптимизации и допущения дают сложность O(u)

\subsubsection{Поиск делителей}
Другой подход заключается в том, что бы искать в данной строке делители модуля(n)
p и q. Несмотря на то, что в теории серверу нет необходимости хранить делители в
памяти, так как нужно посчитать лишь pow(m,d)(mod n), но почти во всех практических
реализациях RSA делители хранятся в памяти в целях оптимизации вычислений.

Можно сделать предположение, что p и q находятся в памяти сразу друг за другом,
и расстояние между их менее значимыми битами примерно v/2. Таким образом мы можем
умножать каждые 2 подряд идущих числа на расстоянии v/2 и сравнивать результат с
n. Таким образом сложность вычислений O(u*pow(v,2)). С помощью дальнейших оптимизаций
мы можем добиться ускорения работы алгоритма до O(n).

\subsubsection{Поиск мест с высокой энтропией}
Процесс поиска можно оптимизировать, если понять какими характеристиками обладает
объект поиска, и искать места с этими характеристиками. Большая часть кода и данных
формируется не случайным образом, а для криптографические ключи редко выбирается
неслучайно. Таким образом мы можем быть уверены, что криптографические ключи находятся
в области с высокой энтропией.

\subsubsection{Способы сокрытия приватных ключей}
\# добавить что-нибудь?

\newpage

\section{Тестирование}
Тестирование

\subsection{Среда тестирования}
Среда тестирования

\subsection{Результаты тестирования}
Результаты тестирования

\newpage

\section{Заключение}
Заключение

\bibliography{bibliography}
\bibliographystyle{plainnat}

\end{document}
