\documentclass[20pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{url}
\usepackage[colorlinks,allcolors=blue]{hyperref}
\usepackage[numbers]{natbib}
\usepackage{amsthm}

\newtheorem*{mydef}{Определение}

\title{Дипломная работа}
\author{Козлов Никита}

\begin{document}

{\huge Извлечение данных о состоянии веб-приложения на основе анализа образа памяти веб-сервера}

\newpage

\section*{Аннотация}
Данная работа посвящена исследованию возможности извлечения конфиденциальных данных из слепков памяти веб сервера. Для исследований и экспериментов использовался веб сервер Apache, а в качестве системы управления содержимым сайта использовался Wordpress. На полученной системе были протестированы
различные методы извлеченя приватных ключей и других конфиденциальных данных.

\newpage

\tableofcontents

\newpage

\section{Введение}

\subsection{Предметная область}
Для работы любого веб приложения необходим веб сервер, который будет обслуживать
всех клиентов. В качестве веб сервера обычно вытупает скомпилированная программа,
так что на данный момент мы можем абстрагироваться от предназначения данной
программы и поговорить о том, что такое дампы памяти.

Дамп памяти - это содержимое рабочей памяти процесса. Он может включать в себя
значения регистров процессора, содержимое стека и многое другое.
Дамп памяти необходим для отладки программы, так как с помощью него разработчик
можем посмотреть состотяние программы на момент ошибки.
С помощью отладчика мы можем посмотреть состояние переменных во всех функциях во
всем стеке вызовов.

Во время работы веб сервера ему приходится держать в памяти многие вещи, такие
как данные последних запросов клиентов, приватные ключи, логины
и пароли от базы данных, конфигурационные данные и многое другое. Таким образом
дамп памяти хранит в себе различную конфиденцеальную информацию.

Дамп памяти может быть получен множеством способов, например если этот самый веб
сервер неправильно сконфигурирован и разрешает чтение файлов из корневой
дирректории веб приложения, то атакующий может его скачать, другим спобом
получения дампа памяти является уязвимость Local File Read, которая позволяет
читать произвольный файл в системе.

Как правило дамп памяти процесса сохраняется автоматически, когда процесс
завершается из-за критической ошибки(например, из-за ошибки сегментации).

Также дамп можно сохранить вручную через отладчик или послав сигнал процессу.

\subsection{Актуальность}
Большое количество неправильно сконфигурированных серверов говорит о том, что
существует реальная возможность того, что атакующие обратят внимание на данную
проблему. Также не было найдено утилит, которые позволяют извлекать
конфиденциальные данные из дампа памяти веб сервера, или исследований о том,
какую информацию можно найти в слепках памяти.

\newpage

\section{Цель работы}
Исследовать возможность получения конфиденциальной информации из дампов памяти веб сервера.

\newpage

\section{Постановка задачи}
На примере веб сервера Apache и сисемы управления содержимым сайта Wordpress
исследовать возможность получения конфиденциальной информации из дампов памяти
веб сервера.

\newpage

\section{Конфиденциальные данные}
Конфиденциальные данные - данные, которые не подлежат разглашению. Такие как
cookies, логины, пароли, токены и многое другое.

\subsection{Методы извлечения приватных данных}
Методы извлечения приватных данных

\subsection{Методы извлечения приватного ключа}
\subsubsection{Введение}
В этой части мы затронем проблемы эффективного извлечения криптографических
ключей в большом объеме данных.

\# Ассиметричная криптография

Предполагается, что мы знаем n(modulus) и e(exponent) используемые схеме RSA
жертвы, которые мы можем узнать из сертификата жертвы, а также имеем строку
длинны u(содержимое дампа памяти процесса веб сервера), для которой известно,
что она содержит приватный ключ d как последовательная запись длинны v бит.
Обычно длинна u имеет порядок pow(10,10), а длинна v имеет порядок pow(10,3).

\subsubsection{Перебор}

Простейший способ поиска приватного ключа, который применим ко всем
криптосистемам, заключается в том, чтобы получить пару открытый текст/шифртекст,
а затем сканировать данную последовательност и проводить последовательные попытки
дешифровки шифротекста используя как ключ каждую последовательность длинны v.

Редкие ложноположительные результаты могут быть устраненны проверкой
дополнительных пар.

Основной проблемой такого подхода является тот факт, что такие вычисления очень
ресурсоемкие, а сложность вычислений растет как куб от размера v модуля. Если мы
хотим попробовать все подстроки длинны v в строке длинны u, то получаем сложность
O(n*pow(v,3)), конечно это полиномиальная сложность, но применять такой алгоритм
не практично.

Проведя оптимизации мы можем снизить сложность до O(n*pow(v,2)), что лучше, но
все еще довольно медленно.

Дальнейшие оптимизации и допущения дают сложность O(u)

\subsubsection{Поиск делителей}

Другой подход заключается в том, что бы искать в данной строке делители модуля(n)
p и q. Несмотря на то, что в теории серверу нет необходимости хранить делители в
памяти, так как нужно посчитать лишь pow(m,d)(mod n), но почти во всех практических
реализациях RSA делители хранятся в памяти в целях оптимизации вычислений.

Можно сделать предположение, что p и q находятся в памяти сразу друг за другом,
и расстояние между их менее значимыми битами примерно v/2. Таким образом мы можем
умножать каждые 2 подряд идущих числа на расстоянии v/2 и сравнивать результат с
n. Таким образом сложность вычислений O(u*pow(v,2)). С помощью дальнейших оптимизаций
мы можем добиться ускорения работы алгоритма до O(n).

\subsubsection{Поиск мест с высокой энтропией}

Процесс поиска можно оптимизировать, если понять какими характеристиками обладает
объект поиска, и искать места с этими характеристиками. Большая часть кода и данных
формируется не случайным образом, а для криптографические ключи редко выбирается
неслучайно. Таким образом мы можем быть уверены, что криптографические ключи находятся
в области с высокой энтропией.

\subsubsection{Способы сокрытия приватных ключей}
\# добавить что-нибудь

\newpage

\section{Тестирование}
Тестирование

\subsection{Среда тестирования}
Среда тестирования

\subsection{Результаты тестирования}
Результаты тестирования

\newpage

\section{Заключение}
Заключение

\bibliography{bibliography}
\bibliographystyle{plainnat}

\end{document}
