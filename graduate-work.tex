\documentclass[20pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{url}
\usepackage[colorlinks,allcolors=blue]{hyperref}
\usepackage[numbers]{natbib}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage[outdir=./]{epstopdf}
\usepackage{listings}

\newtheorem*{mydef}{Определение}

\title{Дипломная работа}
\author{Козлов Никита}

\begin{document}

\thispagestyle{empty}

\begin{center}
\ \vspace{-4cm}

\includegraphics[width=0.5\textwidth]{msu}\\
{Московский государственный университет имени М.В.~Ломоносова}\\
Факультет вычислительной математики и кибернетики\\
Кафедра автоматизации систем вычислительных комплексов (АСВК)

\vspace{5cm}

{\Large Козлов~Никита~Вячеславович}

\vspace{1cm}

{\Large\bfseries
Извлечение данных о состоянии веб-приложения на основе анализа образа памяти веб-сервера\\}

\vspace{1cm}

{\large ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА}
\end{center}

\vfill

\begin{flushright}
  \textbf{Научный руководитель:}\\
  м.н.с. А.А.~Петухов
\end{flushright}

\vfill

\begin{center}
Москва, 2017
\end{center}

\enlargethispage{4\baselineskip}

\newpage

\section*{Аннотация}
Данная работа посвящена исследованию возможности извлечения конфиденциальных
данных из образа памяти веб-сервера. Для исследований и экспериментов
использовался веб-сервер Apache, а в качестве системы управления содержимым
сайта использовался Wordpress. На полученной системе были протестированы
различные методы извлечения приватного ключа и других конфиденциальных данных.

\newpage

\tableofcontents

\newpage

\section{Введение}

\subsection{Предметная область}
Веб-приложения играют значительную роль в жизни современного общества. С их
помощью люди могут оформлять документы, заказывать любые товары, покупать и
продавать ценные бумаги и многое другое. Для работы любого такого веб-приложения
необходим веб-сервер, который будет обслуживать всех клиентов.

Во время работы программы могут произойти различные ошибки\cite{error_types}:
деление на ноль, открытие несуществующего файла, нехватка оперативной памяти,
переполнение буфера, переполнение стека, переполнение кучи, освобождение ранее
не выделенной памяти, обращение на чтение или запись к области памяти, для
которой запрещены чтение или запись, и многие другие виды ошибок. В целях
выявления причин ошибок, которые могут произойти на этапе работы программы
существуют дампы памяти.

\subsection{Дамп памяти}

Дамп памяти\cite{wiki/coredump} - это содержимое рабочей памяти процесса, его
формирует операционная система в случае, когда процесс завершается из-за
критической ошибки, например из-за ошибки сегментации (SIGSEGV). Также дамп можно
сохранить вручную через отладчик или послав специальный сигнал(#TODO на какие сигналы падает корка?) процессу.
Максимальный размер дампа памяти зависит от настроек операционной системы(#TODO как задать и как посмотреть эти настройки?), а его
средний размер составляет несколько гигабайт(#TODO откуда инфа?). Дамп памяти может включать в себя
значения регистров процессора, содержимое стека, глобальные переменные,
переменные окружения, локальные переменные и аргументы функций во всех фреймах
на момент создания дампа памяти и т.д. С его помощью разработчик может посмотреть
состояние программы на момент ошибки.

\begin{lstlisting}
> gdb -q \$(which apache2) core.apache2.23383
Reading symbols from /usr/sbin/apache2...Reading symbols from /usr/lib/debug//usr/sbin/apache2...done.
done.
[New LWP 23383]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Core was generated by `/usr/sbin/apache2 -k start'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007fbbfa5b957f in do_fcntl (arg=0x7fbbfa9f88e0, cmd=7, fd=14)
    at ../sysdeps/unix/sysv/linux/fcntl.c:39
(gdb) bt
#0  0x00007fbbfa5b957f in do_fcntl (arg=0x7fbbfa9f88e0, cmd=7, fd=14)
    at ../sysdeps/unix/sysv/linux/fcntl.c:39
#1  __libc_fcntl (fd=14, cmd=7) at ../sysdeps/unix/sysv/linux/fcntl.c:88
#2  0x00007fbbfa7e1296 in ?? () from /usr/lib/x86_64-linux-gnu/libapr-1.so.0
#3  0x00007fbbf79165a2 in accept_mutex_on () at prefork.c:232
#4  child_main (child_num_arg=child_num_arg@entry=4) at prefork.c:611
#5  0x00007fbbf79169a6 in make_child (s=0x7fbbfb310de0, slot=slot@entry=4) at prefork.c:800
#6  0x00007fbbf7916a06 in startup_children (number_to_start=1) at prefork.c:818
#7  0x00007fbbf79176e0 in prefork_run (_pconf=<optimized out>, plog=0x7fbbfb30c028,
    s=0x7fbbfb310de0) at prefork.c:976
#8  0x00007fbbfb0f19ce in ap_run_mpm (pconf=0x7fbbfb33f028, plog=0x7fbbfb30c028,
    s=0x7fbbfb310de0) at mpm_common.c:94
#9  0x00007fbbfb0eb1a6 in main (argc=3, argv=0x7fffb086f128) at main.c:777
(gdb) select-frame 8
(gdb) info args
pconf = 0x7fbbfb33f028
plog = 0x7fbbfb30c028
s = 0x7fbbfb310de0
(gdb) info locals
pHook = 0x7fbbfb27f660
n = 0
rv = -4
(gdb) select-frame 9
(gdb) info args
argc = 3
argv = 0x7fffb086f128
(gdb) quit
\end{lstlisting}

Во время работы веб-сервера в его оперативной памяти находятся различная
информация: данные последних запросов клиентов, приватные ключи, конфигурационные
файлы, логины и пароли от базы данных, конфигурационные данные и многое другое.
Это значит, что в оперативной памяти хранится различная конфиденциальная информация.

\subsection{Актуальность}
На 2 мая 2017 года 27.9\% сайтов работают под правлением Wordpress.
\cite{number_of_wordpress_sites} В самом Wordpress и в плагинах под него были
найдены различные уязвимости(#TODO какие? Добавить примеры), некоторые(#TODO какие?) из них позволяют вызывать выпадение
дампа памяти, а некоторые(#TODO какие?) дают возможность его прочитать. При этом существует
процент(#TODO как много?) неправильно сконфигурированных веб-серверов, которые позволяют чтение
файлов из корневой дирректории и соотвествующих поддиректорий. Учитывая то,
что большинство сайтов были созданы и поддерживается непрофессионалами(#TODO какой процент?), можно
сделать вывод, что большой процент(#TODO какой?) сайтов, работающих под управлением Wordpress,
уязвимы или неправильно сконфигурированы.

\newpage

\section{Цель работы и поставновка задачи}
Цель работы - исследовать возможность получения конфиденциальных данных из
дампа памяти веб-сервера.

\subsection{Постановка задачи}
На примере веб-сервера Apache и системы управления содержимым сайта Wordpress
исследовать возможность получения конфиденциальной информации из дампов памяти
веб-сервера. Для достижения поставленной цели необходимо:

\begin{itemize}
  \item Ознакомиться с работами по анализу дампов памяти и работами в смежных темах
  \item Выяснить, какие конфиденциальные данные встречаются в дампа памяти веб-сервиса,
сравнить результаты для каждой из интересующих платформ
  \item ...
  (#TODO добавить этапы достижения цели)
\end{itemize}

\newpage

\section{Способы получения дампа памяти}

Атакующий может получить дамп памяти множеством способов:
\begin{itemize}
  \item при неправильной конфигурации веб-сервера становится возможным чтение
  файлов из корневой директории веб-приложения(#TODO добавить directory listing),
  куда может быть сохранен дамп памяти(#TODO объяснить, что эту дирректорию
  используют из простоты).
  \item Другим примером получения дампа памяти является эксплуатация уязвимости
  Local File Inclusion\cite{lfi}, которая позволяет читать произвольный файл в
  системе. (#TODO поправить формулировку)
  \item (#TODO XXE?)
  \item (#TODO SQLI?)
  \item (#RCE?)
\end{itemize}

\newpage

\section{Методы вызова создания дампа памяти}

(#TODO добавить воды на счет того, что нужно понимать как добыть дамп памяти)

(#TODO добавить ссылки)
\begin{itemize}
  \item  Бесконечная рекурсия
    \begin{itemize}
      \item Ошибка в библиотеке GD, когда конец рекурсии определяется на определенную
      структуру данного изображения. Специально сконструированное изображение вызовет
      переполнение буффера и падение PHP.
    \end{itemize}
  \item Ошибки в различных библиотеках.
    \begin{itemize}
      \item Ошибки обработки заголовков. Существуют расширения PHP,такие как exif, GD,
        imagemagic, и другие, которые позволяют работать с изображениями. Для работы
        с изображениями необходимо выделить память, а необходимый объем определяется
        с помощью заголовков изображения. Таким образом выставляя специальные значения
        заголовков можно добиться падения PHP.
    \end{itemize}
  \item Уязвимости в различных встроенных функциях.
    \begin{itemize}
      \item CVE-2010-3710 когда использовался мод FILTER\_VALIDATE\_EMAIL, злоумышленник
        мог вызвать отказ работы сервиса из-за использования большого объема памяти
        используя очень длинный почтовый адрес.
      \item Ошибка в функции pack(). Вызванная со специальными аргументами эта функция
        заставляет интерпретатор PHP выделить памяти больше чем есть на сервере, что
        вызовет падение PHP.
    \end{itemize}
 \item ...
\end{itemize}

\newpage

\section{Конфиденциальные данные}
Конфиденциальные данные - данные, которые не подлежат разглашению. Перечислим
некоторые из них.

Cookies пользователя или их логины и пароли (хеши паролей) являются ярким
примером конфиденциальных данных. С их помощью можно получить неограниченный
доступ к аккаунту жертвы.

Конфигурационные файлы веб-сервера, исходные коды веб-сервиса и даже переменные
окружения содержат информацию, которая может помочь атакующему найти и
эксплуатировать различные уязвимости. Они являются дургим примером
конфиденицальных данныех.

Конфигурационные файлы веб-сервиса, которые могут содержать логины, пароли, токены
для доступа к базам данных, FTP серверам и другим сервисам, и соответственно(#TODO нужны запятые?) сами
логины, пароли и токены являются конфиденциальными данными, попадание которых в
руки злоумышленника может привести к раскрытию данных пользователей сервиса и
компроментации самого сервиса.

Для шифрования общения между клиентом и сервером используется криптографический
протокол TLS\cite{tls} или его предшественник SSL. Для аутентификации сервера
используются инфраструктура открытых ключей\cite{pki}. Одним из ключевых моментов
в инфраструктуре открытых ключей является то, что приватный ключ должен быть
известен только владельцу сервера. Если злоумышленник сможет похитить приватный
ключ, то он сможет осуществить атаку "Человек посередине"\cite{mitm}.
(#TODO добавить инфы про mitm)

\subsection{Похожие исследования}
Heartbleed\cite{heartbleed} - критическая уязвимость в популярной криптографической
библиотеке OpenSSL. Эта уязвимость позволяла атакующему, пославшему специально
сформированный пакет, читать части оперативной памяти размером до 64КБ. Таким
образом атакующий мог подслушивать отрывки взаимодействия пользователей с сервисом.
Скомпрометированными могли оказаться приватные ключи, используемые для шифрования,
логины и пароли пользователей и другие конфиденциальные данные.

После того как была опубликована информация об уязвимости, компания cloudflare
провела собственное расследование\cite{heartbleed/investigation} целью которого
было выяснить, возможно ли извлечь приватный ключ из памяти веб-сервервера с
уязвимой версией OpenSSL. Во время этого расследования у инженеров компании не
получилось извлечь приватный ключ, но для того чтобы глубже изучить проблему
было организовано публичное соревнование\cite{hearbleed/investigation} с той же
самой целью. Каждый желающий мог попробовать извлечь приватный ключ из
данного веб-сервера с уязвимой версией OpenSSL.

Победителем данного соревнования стали Fedor Indutny\cite{heartbleed/Indutny} и
Ilkka Mattila через 9 часов с момента старта соревнования. Они успешно смогли
извлечь приватный ключ. Fedor смог получить ключ отправив около 2.5 миллионов
запросов, а у Ilkka получилось это сделать за 100 тысяч запросов.

По итогам соревнования coudflare рекомендовала всем перевыпустить все сертификаты
и ускорила перевыпуск сертификатов своих клиентов.(#TODO проверить действительно
ли они выпускают сертификаты)

\subsection{Методы извлечения приватного ключа \cite{playing-hide-and-seek-with-stored-keys} }

\subsubsection{Введение}
В основу криптографической системы с открытым ключом RSA положена сложность задачи
факторизации произведения двух больших простых чисел. Для шифрования используется
операция возведения в степень по модулю большого числа. Для дешифрования за
разумное время необходимо уметь вычислять функцию Эйлера от данного большого
числа, для чего необходимо знать разложение числа на простые множители.(#TODO
для подсчета функции Эйлера это не является необходимым условием)

Важные числа в криптографической системе rsa:
\begin{itemize}
  \item простые числа p и q
  \item их произведение $n=p \cdot q$, которое называется модулем
  \item значение функции Эйлера от числа n: $\varphi (n)=(p-1)\cdot (q-1)$.
  \item целое число e, которое называется открытой экспонентой
    (1<e<$\varphi$ (n)), взаимно простое со значением функции $\varphi(n)$.
  \item число d, мультипликативно обратное к числу e по модулю
    $\varphi$ (n), то есть число, удовлетворяющее сравнению: $d\cdot e\equiv 1{\pmod {\varphi (n)}}$.
\end{itemize}

\subsubsection{Исходные данные}
Известны n и e используемые в схеме RSA жертвы, их можно узнать из сертификата
жертвы, а также имеем строку длинны u - содержимое дампа памяти процесса
веб-сервера, для которой известно, что она содержит приватный ключ d как
последовательную запись длинны v бит. Обычно длинна u имеет порядок $10^10$,
а длинна v имеет порядок $10^3$.

\subsubsection{Алгоритм: последовательный перебор}
Простейший способ поиска приватного ключа, который применим ко всем
криптосистемам, заключается в том, чтобы получить пару открытый текст/шифротекст,
а затем сканировать данную последовательность и проводить попытки дешифровки
шифротекста используя как ключ каждую последовательность длинны v. (#TODO рассказать,
как можно получить пару открытый текст/шифротекст)

Редкие ложноположительные результаты могут быть устранены проверкой
дополнительных пар текст/шифротекст.

Основной проблемой такого подхода является тот факт, что такие вычисления очень
ресурсоемкие, а сложность вычислений растет как куб от размера v модуля.
Перебор все подстрок длинны v в строке длинны u, дает сложность O(n*$v^3$),
конечно это полиномиальная сложность, но применять такой алгоритм на практике
очень ресурсоемко.

Проведя оптимизации, возможно снизить сложность до O(u). (#TODO описать оптимизации)

\subsubsection{Алгоритм: поиск делителей}
Этот подход заключается в том, поиске в данной строке делители модуля n - p и q.
Несмотря на то, что в теории серверу нет необходимости хранить делители в
памяти, так как нужно посчитать лишь $m^d$(mod n), но почти во всех практических
реализациях RSA делители хранятся в памяти в целях оптимизации вычислений.

Допустимо сделать предположение, что p и q находятся в памяти сразу друг за другом,
и расстояние между их менее значимыми битами примерно v/2. Таким образом можно
умножать каждые 2 подряд идущих числа на расстоянии v/2 и сравнивать результат с
n. Таким образом сложность вычислений O(u*$v^2$).

С помощью дальнейших оптимизаций возможно добиться ускорения работы алгоритма
до O(n). (#TODO описать оптимизации)

\subsubsection{Оптимизации: поиск мест с высокой энтропией}
Процесс поиска можно оптимизировать, если понять какими характеристиками обладает
объект поиска, и искать места с этими характеристиками. Большая часть кода и данных
формируется неслучайным образом, а криптографические ключи редко выбирается
неслучайно. Таким образом можно утверждать, что криптографические ключи находятся
в области с высокой энтропией.

(#TODO добавить картинки с изображением мест с высокой энтропией)

\subsubsection{Оптимизации: анализ структур кода приложения}
Альтернативным способом нахождения приватного ключа является поиск структур
данных, специфичных для конкретного веб-сервера. Посмотрев структуру данных в которой
хранится приватный ключ, в данном случае это (#TODO добавить имя файла со структурой
данных и саму структуру данных), будем искать в дампе памяти эту структуру данных
и пытаться расшифровать некоторое сообщение или найти делитель модуля.

Таким образом работает утилита passe-partout, которая может извлекать приватный ключ из
памяти работающего веб-приложения.

(#TODO добавить инфы из доки про утилиту passe-partout)

\subsection{Извлечение других конфиденциальных данных}

\subsubsection{Извлечение логинов и паролей, конфигурационных файлов}
(#TODO написать как искать логины, пароли, кукесы)

\subsubsection{Извлечение файлов с известными сигнатурами}
(#TODO написать про то, как работает binwalk)

\newpage

\section{Тестирование}

\subsection{Методика тестирования}

\begin{itemize}
  \item Разворачиваем(#TODO как?) чистую машину с нужной версией операционной системы
  \item На полученной машине устанавливаем все необходимые пакеты для работы
  веб-сервера и системы управления содержимым сайта(#TODO рассказать про тулзы)
  \item Добавляем пользователей, рядового посетителя и администратора
  \item Делаем несколько типовых для пользователя и администратора действий
  \item Вызываем создание дампа памяти с помощью специального сигнала
  \item Получаем один или несколько дампов памяти, в зависимости от настроек
  веб-сервера
  \item Запускаем утилиту для анализа дампов памяти, которая ищет в дампе
  заранее заданные конфиденциальные данные.
  \item Сохраняем полученные результаты
\end{itemize}

\subsection{Результаты тестирования}
Результаты тестирования

\begin{table}[]
\centering
\caption{My caption}
\label{my-label}
\begin{tabular}{|l|l|l|}
\hline
Эксперимент                                                                                 & Ubuntu trusty 64               & Ubuntu xenial 64 \\ \hline
database name                                                                                   & +                              &                  \\ \hline
database user                                                                                   & +                              &                  \\ \hline
database password(plaintext)                                                                    & +                              &                  \\ \hline
ftp user                                                                                        & +                              &                  \\ \hline
ftp password(plaintext)                                                                         & +                              &                  \\ \hline
wordpress user name                                                                             & + (выпадает не во всех корках) &                  \\ \hline
wordpress user password                                                                         & -                              &                  \\ \hline
wordpress user passwords hash                                                                   & + (выпадает не во всех корках) &                  \\ \hline
wordpress user email                                                                            & + (выпадает не во всех корках) &                  \\ \hline
ssl private key                                                                                 & +                              &                  \\ \hline
Client requests                                                                                 & + (выпадают не во всех корках) &                  \\ \hline
web pages(html/js/css)                                                                          & +- некоторые части html/js/css &                  \\ \hline
Source code                                                                                     & -                              &                  \\ \hline
process envrironment                                                                            & +                              &                  \\ \hline
Apache(global) configs                                                                          & +                              &                  \\ \hline
Apache(vhost) configs                                                                           & +                              &                  \\ \hline
\begin{tabular}[c]{@{}l@{}}Wordpress secrets\\ (AUTH\_KEY, SECURE\_AUTH\_KEY, ...)\end{tabular} & -                              &                  \\ \hline
\end{tabular}
\end{table}
\newpage

\section{Заключение}
{#TODO Заключение}

\newpage

\bibliography{bibliography}
\bibliographystyle{plainnat}

\end{document}
