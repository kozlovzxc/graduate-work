\documentclass[20pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{url}
\usepackage[colorlinks,allcolors=blue]{hyperref}
\usepackage[numbers]{natbib}
\usepackage{amsthm}

\newtheorem*{mydef}{Определение}

\title{Дипломная работа}
\author{Козлов Никита}

\begin{document}

{\huge Извлечение данных о состоянии веб-приложения на основе анализа образа памяти веб-сервера}

\newpage

\section*{Аннотация}
Данная работа посвящена исследованию возможности извлечения конфиденциальных
данных из образа памяти веб-сервера. Для исследований и экспериментов
использовался веб-сервер Apache, а в качестве системы управления содержимым
сайта использовался Wordpress. На полученной системе были протестированы
различные методы извлечения приватного ключа и других конфиденциальных данных.

\newpage

\tableofcontents

\newpage

\section{Введение}

\subsection{Предметная область}
Веб-приложения играют значительную роль в жизни современного общества. С их
помощью люди могут оформлять документы, заказывать любые товары, покупать и
продавать ценные бумаги и многое другое. Для работы любого такого веб-приложения
необходим веб-сервер, который будет обслуживать всех клиентов.

В целях выявления причин ошибок, которые могут произойти на этапе кодирования,
тестирования или работы существуют дампы памяти. Дамп памяти\cite{wiki/coredump}
- это содержимое рабочей памяти процесса, его формирует операционная система в
случае, когда процесс завершается из-за критической ошибки, например из-за ошибки
сегментации (SIGSEGV). Также дамп можно сохранить вручную через отладчик или послав
специальный сигнал процессу. Максимальный размер дампа памяти зависит от
настроек операционной системы, а его средний размер составляет несколько
гигабайт. Дамп памяти может включать в себя значения регистров процессора,
содержимое стека, глобальные переменные, переменные окружения, локальные
переменные и аргументы функций во всех фреймах на момент создания дампа памяти
и т.д. С его помощью разработчик может посмотреть состояние программы на момент
ошибки.

Во время работы веб-сервера в его оперативной памяти находятся различная
информация: данные последних запросов клиентов, приватные ключи, логины и пароли
от базы данных, конфигурационные данные и многое другое. Таким образом дамп
памяти хранит в себе различную конфиденциальную информацию.

Атакующий может получить дамп памяти множеством способов, например при
неправильной конфигурации веб-сервера становится возможным чтение файлов из
корневой директории веб-приложения, куда вероятно(настройки по умолчанию)
будет сохранен дамп памяти. Другим примером получения дампа памяти является
эксплуатация уязвимости Local File Inclusion, которая позволяет читать
произвольный файл в системе. Список примеров не является исчерпывающим, дамп
можно получить с помощью различных инъекций и других уязвимостей.

\subsection{Актуальность}
На 2 мая 2017 года 27.9\% сайтов работают под правлением Wordpress.
\cite{number_of_wordpress_sites} В самом wordpress и в плагинах под него были
найдены различные уязвимости, некоторые из них позволяют вызывать выпадение
дампа памяти, а некоторые дают возможность его прочитать. При этом существует
процент неправильно сконфигурированных веб-серверов, которые позволяют чтение
файлов из корневой дирректории и соотвествующих поддиректорий. Учитывая то,
что большинство сайтов были созданы и поддерживается непрофессионалами, можно
сделать вывод, что большой процент сайтов, работающих под управлением Wordpress,
уязвимы или неправильно сконфигурированы.

\newpage

\section{Цель работы}
Исследовать возможность получения конфиденциальной информации из дампов памяти веб-сервера.

\newpage

\section{Постановка задачи}
На примере веб-сервера Apache и системы управления содержимым сайта Wordpress
исследовать возможность получения конфиденциальной информации из дампов памяти
веб-сервера.

\begin{itemize}
  \item Ознакомиться с работами по анализу дампов памяти и работами в смежных темах
  \item Выяснить, какие конфиденциальные данные встречаются в дампа памяти веб-сервиса,
сравнить результаты для каждой из интересующих платформ
  \item ...
\end{itemize}

\newpage

\section{Конфиденциальные данные}
Конфиденциальные данные - данные, которые не подлежат разглашению. Перечислим
некоторые из них.

Cookies пользователя или их логины и пароли (хеши паролей) являются ярким
примером конфиденциальных данных. С их помощью можно получить неограниченный
доступ к аккаунту жертвы.

Конфигурационные файлы веб-сервера, исходные коды веб-сервиса и даже переменные
окружения содержат информацию, которая может помочь атакующему найти и
эксплуатировать различные уязвимости. Они являются дургим примером
конфиденицальных данныех.

Конфигурационные файлы веб-сервиса, которые могут содержать логины, пароли, токены
для доступа к базам данных, FTP серверам и другим сервисам, и соответственно сами
логины, пароли и токены являются конфиденциальными данными, попадание которых в
руки злоумышленника может привести к раскрытию данных пользователей сервиса и
компроментации самого сервиса.

Для шифрования общения между клиентом и сервером используется криптографический
протокол TLS\cite{tls} или его предшественник SSL. Для аутентификации сервера
используются инфраструктура открытых ключей\cite{pki}. Одним из ключевых моментов
в инфраструктуре открытых ключей является то, что приватный ключ должен быть
известен только владельцу сервера. Если злоумышленник сможет похитить приватный
ключ, то он сможет осуществить атаку "Человек посередине"\cite{mitm}.

\subsection{Похожие исследования}
Heartbleed\cite{heartbleed} - критическая уязвимость в популярной криптографической
библиотеке OpenSSL. Эта уязвимость позволяла атакующему, пославшему специально
сформированный пакет, читать части оперативной памяти размером до 64КБ. Таким
образом атакующий мог подслушивать отрывки взаимодействия пользователей с сервисом.
Скомпрометированными могли оказаться приватные ключи, используемые для шифрования,
логины и пароли пользователей и другие конфиденциальные данные.

После того как была опубликована информация об уязвимости, компания cloudflare
провела собственное расследование\cite{heartbleed/investigation} целью которого
было выяснить, возможно ли извлечь приватный ключ из памяти веб-сервервера с
уязвимой версией OpenSSL. Во время этого расследования у инженеров компании не
получилось извлечь приватный ключ, но для того чтобы глубже изучить проблему
было организовано публичное соревнование\cite{hearbleed/investigation} с той же
самой целью. Каждый желающий мог попробовать извлечь приватный ключ из
данного веб-сервера с уязвимой версией OpenSSL.

Победителем данного соревнования стали Fedor Indutny\cite{heartbleed/Indutny} и
Ilkka Mattila через 9 часов с момента старта соревнования. Они успешно смогли
извлечь приватный ключ. Fedor смог получить ключ отправив около 2.5 миллионов
запросов, а у Ilkka получилось это сделать за 100 тысяч запросов.

По итогам соревнования coudflare рекомендовала всем перевыпустить все сертификаты
и ускорила перевыпуск сертификатов своих клиентов.

\subsection{Методы извлечения приватного ключа \cite{playing-hide-and-seek-with-stored-keys} }

\subsubsection{Введение}
В основу криптографической системы с открытым ключом RSA положена сложность задачи
факторизации произведения двух больших простых чисел. Для шифрования используется
операция возведения в степень по модулю большого числа. Для дешифрования за
разумное время необходимо уметь вычислять функцию Эйлера от данного большого
числа, для чего необходимо знать разложение числа на простые множители.

Важные числа в криптографической системе rsa:
\begin{itemize}
  \item простые числа p и q
  \item их произведение $n=p \cdot q$, которое называется модулем
  \item значение функции Эйлера от числа n: $\varphi (n)=(p-1)\cdot (q-1)$.
  \item целое число e, которое называется открытой экспонентой
    (1<e<$\varphi$ (n)), взаимно простое со значением функции $\varphi(n)$.
  \item число d, мультипликативно обратное к числу e по модулю
    $\varphi$ (n), то есть число, удовлетворяющее сравнению: $d\cdot e\equiv 1{\pmod {\varphi (n)}}$.
\end{itemize}

\subsubsection{Исходные данные}
Предполагается, что известны n и e используемые в схеме RSA жертвы (их можно
узнать из сертификата жертвы), а также имеем строку длинны u - содержимое дампа
памяти процесса веб-сервера, для которой известно, что она содержит приватный
ключ d как последовательная запись длинны v бит. Обычно длинна u имеет порядок
$10^10$, а длинна v имеет порядок $10^3$.

\subsubsection{Алгоритм: перебор}
Простейший способ поиска приватного ключа, который применим ко всем
криптосистемам, заключается в том, чтобы получить пару открытый текст/шифротекст,
а затем сканировать данную последовательность и проводить попытки дешифровки
шифротекста используя как ключ каждую последовательность длинны v.

Редкие ложноположительные результаты могут быть устранены проверкой
дополнительных пар текст/шифротекст.

Основной проблемой такого подхода является тот факт, что такие вычисления очень
ресурсоемкие, а сложность вычислений растет как куб от размера v модуля.
Перебор все подстрок длинны v в строке длинны u, дает сложность O(n*$v^3$),
конечно это полиномиальная сложность, но применять такой алгоритм на практике
очень ресурсоемко.

Проведя оптимизации, возможно снизить сложность до O(u).

\subsubsection{Алгоритм: поиск делителей}
Этот подход заключается в том, поиске в данной строке делители модуля n, p и q.
Несмотря на то, что в теории серверу нет необходимости хранить делители в
памяти, так как нужно посчитать лишь $m^d$(mod n), но почти во всех практических
реализациях RSA делители хранятся в памяти в целях оптимизации вычислений.

Допустимо сделать предположение, что p и q находятся в памяти сразу друг за другом,
и расстояние между их менее значимыми битами примерно v/2. Таким образом можно
умножать каждые 2 подряд идущих числа на расстоянии v/2 и сравнивать результат с
n. Таким образом сложность вычислений O(u*$v^2$). С помощью дальнейших оптимизаций
возможно добиться ускорения работы алгоритма до O(n).

\subsubsection{Оптимизации: поиск мест с высокой энтропией}
Процесс поиска можно оптимизировать, если понять какими характеристиками обладает
объект поиска, и искать места с этими характеристиками. Большая часть кода и данных
формируется неслучайным образом, а криптографические ключи редко выбирается
неслучайно. Таким образом можно утверждать, что криптографические ключи находятся
в области с высокой энтропией.

\subsubsection{Оптимизации: анализ структур кода приложения}
Альтернативным способом нахождения приватного ключа является поиск структур
данных, специфичных для конкретного веб-сервера. Посмотрев структуру данных в которой
хранится приватный ключ, в данном случае это {{privKeyStructFilename}}, будем искать
в дампе памяти эту структуру данных и пытаться расшифровать некоторое сообщение
или найти делитель модуля. Таким образом работает утилита passe-partout, которая
может извлекать приватный ключ из памяти работающего веб-приложения.

\newpage

\section{Методы вызова создания дампа памяти}

\begin{itemize}
  \item  Бесконечная рекурсия
    \begin{itemize}
      \item Ошибка в библиотеке GD, когда конец рекурсии определяется на определенную
      структуру данного изображения. Специально сконструированное изображение вызовет
      переполнение буффера и падение PHP.
    \end{itemize}
  \item Ошибки в различных библиотеках.
    \begin{itemize}
      \item Ошибки обработки заголовков. Существуют расширения PHP,такие как exif, GD,
        imagemagic, и другие, которые позволяют работать с изображениями. Для работы
        с изображениями необходимо выделить память, а необходимый объем определяется
        с помощью заголовков изображения. Таким образом выставляя специальные значения
        заголовков можно добиться падения PHP.
    \end{itemize}
  \item Уязвимости в различных встроенных функциях.
    \begin{itemize}
      \item CVE-2010-3710 когда использовался мод FILTER\_VALIDATE\_EMAIL, злоумышленник
        мог вызвать отказ работы сервиса из-за использования большого объема памяти
        используя очень длинный почтовый адрес.
      \item Ошибка в функции pack(). Вызванная со специальными аргументами эта функция
        заставляет интерпретатор PHP выделить памяти больше чем есть на сервере, что
        вызовет падение PHP.
    \end{itemize}
 \item ...
\end{itemize}

\newpage

\section{Тестирование}

\subsection{Цель тестирования}

\subsection{Методика тестирования}

\begin{itemize}
  \item Разворачиваем чистую машину с нужной версией операционной системы
  \item На полученной машине устанавливаем все необходимые пакеты для работы
  веб-сервера и системы управления содержимым сайта
  \item Добавляем пользователей, рядового посетителя и администратора
  \item Делаем несколько типовых для пользователя и администратора действий
  \item Вызываем создание дампа памяти с помощью специального сигнала
  \item Получаем один или несколько дампов памяти, в зависимости от настроек
  веб-сервера
  \item Запускаем утилиту для анализа дампов памяти, которая ищет в дампе
  заранее заданные конфиденциальные данные.
  \item Сохраняем полученные результаты
\end{itemize}

\subsection{Результаты тестирования}
Результаты тестирования

\newpage

\section{Заключение}
Заключение

\newpage

\bibliography{bibliography}
\bibliographystyle{plainnat}

\end{document}
